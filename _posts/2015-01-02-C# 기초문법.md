---
layout: post
title:  "C# 기초문법"
date:   2015-01-02 17:04:00
categories: Programming(C#)
tags: C#
---

* content
{:toc}

C# 프로그래밍 기초 문법
도서(뇌를 자극하는 C# 4.0 프로그래밍 - 박상현 저)의 내용을 정리합니다.

## 1. .NET Framework

C# 이라고 하면  항상 .NET Framework 에 대한 얘기가 나오곤 합니다.

.NET Framework 는 Microsoft에서 개발한 웹 기반, 윈도우 기반 application을 개발할 수 있고, 실행시킬 수 있는 프레임워크이며, .NET 표준에 따르는 프로그래밍 언어로 개발된 프로그램의 실행환경이라고 할 수 있습니다.

.NET Framework의 구성을 그림으로 보면 다음과 같습니다.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/01-1.PNG)

위에서 하나씩 살펴보자면

여기서 .NET 표준을 따르는 (CLS; Common Language Specification)을 따르는 여러 언어를 제공합니다.

(대표적으로 C# 외에 VB.NET , Managed C++ , Jscript.NET , j # 등이 있다.)

Class Library 구성을 보면 다음과 같습니다.
* ASP.NET Web Forms Web Services : Web service와 Web apps를 개발 
* Windows Forms : Windows 프로그래밍
* ADO .NET and XML : XML 및 데이터베이스 활용
* Base Class Library : CLR 지원을 위한 핵심 클래스 라이브러리

**Common Language Runtime(CLR)**

.NET 언어로 작성된 프로그램을 실행하고 관리하는 실행환경이며 Java의 virtual machine에 해당한다고 볼 수 있습니다. 

CLR은 .NET에서 동작하는 프로그램을 적재하고, 프로그램의 동적 컴파일, 프로그램의 실행, 메모리관리 (Garbage Collection) ,프로그램의 예외처리, 언어 간의 상속 지원, COM과의 상호 운영성 지원 등을 가능케 합니다. 

.NET 언어라 하면 C#뿐만 아니라 위에서 나열하였던 VB.NET 등 .NET 표준을 따르는 여러언어들은 CLR을 통해 프로그램을 실행할 수 있게 됩니다.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/01-2.PNG)

이것이 가능한 이유는 Intermediate Language (IL, 중간언어) 라는 기계어로 변환하기 쉬운 상태의 중간 단계의 언어로 .NET에서 번역되어 실행되기 위해 IL형태로 컴파일을 하는데, IL을 기계어로 바꾸는 번역기만 제공되면 어떤 플랫폼에서도 실행가능합니다. 

JIT (Just-In-Time) 컴파일러를 통해 IL을 동적으로 컴파일하는데 .NET 에서는 이와같이 프로그램을 2번 컴파일 합니다. Assembly는 이 때 IL로 컴파일된 결과 파일들을 패키징 한 것을 말합니다.(.exe는 여러개의 class와 Main프로그램을 포함하고, dll은 class만을 포함한다고 생각하면 된다.)

또 .NET 언어가 지켜야 하는 스펙으로 Common Language Specifications (CLS) 로 다른 .NET 언어로 작성된 것도 호환되어 동작 가능하게 합니다. 이 과정에서 Common Type System (CTS) 라는 .NET 언어마다 Data type이 다를 수 있는데,이를 언어나 시스템 환경에 관계없이 동일한 Data type을 유지하기 위한 규약이 사용되기도 합니다.

쉽게 요약하면, C# 컴파일러는 우리가 작성한 코드를 IL로 작성된 실행파일을 만들게 되고, 이 파일을 실행시키면 CLR이 IL을 읽어 다시 OS에 이해할수 있는 코드로 컴파일하여 실행시킵니다. 이렇게 서로 다른 언어가 만나는 지점이 IL언어이고, CLR이 다시 자신이 설치되어 있는 플랫폼에 최적화시켜 컴파일한 후 실행하게 됩니다.

이렇게 플랫폼에 최적화된 코드를 만들어 내는 장점이 있으나, 단점은 실행시에 이루어지는 컴파일의 비용부담이 되겠습니다.


## 2. Data Type (자료형)

C#에서 제공하는 데이터 형식은 숫자, 텍스트 뿐만 아니라, 이미지, 소리까지 다룰 수 있는 데이터 형식을 제공합니다. 

데이터 형식은 기본 데이터형식(Primitive Type) 과 복합 데이터형식 (Complex Data Type) 으로 나눌 수 있습니다.
 * 기본 데이터형식은 흔히 생각하는 int , double 과 같은 개념
 * 복합 데이터형식은 기본데이터 형식을 기본으로 하는 구조체나 클래스 등

기본 데이터형식과 복합 데이터형식을 다시 값 형식과 참조 형식으로 분류할 수 있습니다.


**값 형식 (Value Types), 참조 형식 (Reference Types)**

값 형식은 메모리 영역 중 스택(Stack) 영역 에 저장되며, 선언 되었던 코드 블록이 끝나면 스택영역에서 데이터가 제거됩니다.
스택에 쌓인 데이터들이 코드 블록이 끝나는 순간 제거 된다는 것은 값 형식의 장점이자 단점이 됩니다.

코드 블록이 끝나는 순간 데이터가 제거되기 때문에 메모리영역이 전부 회수되지만, 코드 블록안에서만 사용가능합니다.

참조 형식은 메모리 영역 중 힙(Heap) 영역에 데이터를 저장하는데, 힙 영역은 코드 블록과 상관 없이 데이터는 사라지지 않습니다. 참조 형식의 변수는 힙과 스택을 동시에 이용합니다. 힙 영역에는 데이터의 값을 저장하고, 스택 영역에는 이 데이터의 주소를 저장합니다. 스택 영역은 코드 블록이 끝나는 순간 사라지지만 ( 데이터의 주소), 힙 영역에 데이터의 값은 사라지지 않습니다.

C# 에서는 CLR의 가비지 컬렉터 (Garbage Collector) 가 힙에 사용하지 않는 객체를 자동으로 제거해줍니다.

**object 형식**

C#은 모든 데이터 형식을 다룰 수 있는 object형식이 존재합니다.
 
모든 데이터 형식 (기본 데이터 형식 뿐만 아니라 모든 복합 데이터 형식, 프로그래머가 만드는 데이터형식 까지도) 자동으로 object 형식으로부터 상속받게 하였기 때문입니다.

정수 형식은 short 와 int 의 처리가 다르고, 부동 소수점 형식은 float 와 double 가 처리가 다른데도 가능한 이유는 박싱(boxing) 과 언박싱(unboxing) 이라는 메커니즘이 있기 때문입니다.

**박싱(boxing), 언박싱(unboxing)**

object 형식은 참조 형식이기 때문에 힙에 데이터를 할당합니다.

하지만 object 형식에 값 형식의 데이터 (int와 같은)를 할당하면 object 형식은 박싱을 수행해서 데이터를 힙에 할당합니다. 이 object 형식을 다시 값 형식의 변수에 할당하면, object 형식의 데이터를 언박싱하여 데이터 값을 값 형식의 변수에 할당합니다.

예를 들어, 다음과 같은 코드가 있습니다.
```
object a= 10;
int b = (int) a;
```
이럴 경우 10을 박싱하여 힙에 저장하고, a는 박싱한 10의 주소를 갖습니다. 다시 b에 저장하고자 할때 a는 언박싱 되어 10이 b에 저장됩니다.

**열거 형식(Enumerator)**

종류는 같지만, 다른 값을 갖는 상수들을 선언해야 할때 유용합니다.

예를 들면, 메시지 박스를 띄웠을 때 사용자로 부터 받는 응답이 Yes, No, Cancel 과 같을 때 상수로 선언하여 컨트롤하면 쉽습니다.
```
enum 열거형식명 : 기반자료형 {상수1, 상수2, .... }
```
기반자료형은 정수 계열(byte, short, int, long 등)만 사용할 수 있습니다. 생략할 경우 컴파일러가 int 형으로 사용합니다.

enum 의 여러가지 사용방법은 다음과 같습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        enum DialogResult { YES=1 , NO , CANCEL }
 
        static void Main(string[] args)
        {
            Console.WriteLine(DialogResult.YES);  // YES
            Console.WriteLine(DialogResult.NO); // NO
            Console.WriteLine(DialogResult.CANCEL); // CANCEL
            Console.WriteLine();
            Console.WriteLine((int)DialogResult.YES); // 1
            Console.WriteLine((int)DialogResult.NO); // 2
            Console.WriteLine((int)DialogResult.CANCEL); // 3
            Console.WriteLine();
            Console.WriteLine( (DialogResult) 1); // YES
            Console.WriteLine( (DialogResult) 2); // NO
            Console.WriteLine( (DialogResult) 3); // CANCEL
        }
    }
}
```


**Nullable 형식**

C#에서는 메모리 공간에 어떤 값이든 넣도록 강제합니다. 하지만 어떤 값도 가지지 않는 변수가 필요할 때가 있습니다. 0 이 아니라 아예 비어있는 변수, 즉 null 한 변수를 말합니다.
```
데이터형식 ? 변수이름;
```

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
 
        static void Main(string[] args)
        {
            int? a = null;
            double? b = null;
            Console.WriteLine(a.HasValue); // False
            Console.WriteLine(a == b); // True
            a = 3;
            Console.WriteLine();
            Console.WriteLine(a.HasValue); // True
            Console.WriteLine(a != null); // True
            Console.WriteLine(a.Value); // 3
        }
    }
}
```


**var 형식**

C#은 변수나 상수에 대해 깐깐하게 형식 검사를 하는 강력한 형식의 언어 (Strong Typed Language) 입니다.

이는 프로그래머의 실수를 줄여줍니다. 하지만 int, uint, long, ulong 등 수많은 형식을 외워야 하기 때문에 단점도 존재합니다. 이를 극복하기 위해 var 키워드를 통해 컴파일러가 해당 변수의 형식을 알아서 지정해줍니다.

```
var a= 3;  // a는 int형식
var b= "Hello"; // b는 string 형식
```


var 형식은 지역 변수로만 사용할 수 있습니다.

그리고 클래스의 필드를 선언할 때는 반드시 명시적인 형식을 선언해야 합니다.
클래스의 필드는 보통 생성자에서 초기화하게 되는데 var키워드로 선언하면 무슨 형식인지 컴파일러가 알 수 없기 때문입니다.

참고로 C#에서는 전역변수를 지원하지 않습니다. 코드의 가독성을 해치고 오류를 낳는 원흉으로 지적되었기 때문에 전역변수를 지원하지 않게 되었습니다.

다음과 같이 선언하면 var 와 object 가 헷갈릴 수 있으나 전혀 다른 개념입니다.
```
object a= 10;
var b = 10;
```
위 코드가 컴파일되어 실행하면  object 형식에서 CLR은 20을 박싱해서 힙에 넣고 a가 힙을 가리키게 됩니다.

var 형식에서 컴파일 시점에 컴파일러가 적합한 데이터형식을 파악하여 int b=10; 으로 되어 CLR은 int b=10; 으로 스택에 10을 올립니다.

## 3. Method (메소드)

객체지향 프로그래밍 언어에서 사용하는 용어로 C와 C++에서는 함수(Function) 이라 불렸고, 파스칼에서는 프로시져(Procedure)라고 불렸습니다. 또는 서브루틴(Subroutine), 서브프로그램(Subprogram)이라고 부르기도 합니다.

메소드를 사용할때 매개변수 전달방식에 대해서 설명하고자 합니다.

 
**참조에 의한 매개 변수 전달 (Call by reference)**

C에서는 포인터를 이용하여 직접 데이터의 주소를 매개변수로 전달하여 함수에서 값을 컨트롤하였습니다.

C#에서는 프로그래머가 메모리를 참조한다는 것 자체가 위험하다고 판단하였기 때문에 포인터를 사용할 수 없게 했습니다. 
(하지만 설정으로 포인터를 사용가능하게 만들 수는 있습니다.)

Call by reference 를 이용하여 두개의 데이터의 값을 바꾸는 Swap 메소드 를 만들어 보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
  
namespace CsharpStudy
{
    class Program
    {
        static void Swap(ref int x, ref int y)
        {
            int temp = x;
            x = y;
            y = temp;
        }
        static void Main(string[] args)
        {
            int x = 3;
            int y = 5;
            Swap(ref x, ref y);
            Console.WriteLine("{0} , {1}", x, y); // 5, 3
        }
    }
}
```

주의하실점은 매개변수를 전달할때, 함수에서 매개변수를 받을 때 ref 키워드를 붙여서 명확한 표현을 해주셔야 합니다.

그리고, C#에서는 전부 클래스 단위로 움직입니다. Main 메소드도 마찬가지로 클래스 안에 있습니다만, static 키워드로 정적으로 존재하기 때문에 Main에서 Swap메소드를 사용하기 위해서 Swap메소드도 static으로 선언되어야 합니다.

**출력 전용 매개변수**

메소드가 두개 이상의 반환 값을 갖고 싶을 때 사용합니다.
예를 들어 어떤 두 숫자를 가지고 몫과 나머지를 동시에 반환하고 싶을 때는 다음과 같이 함수를 만들면 됩니다.
```
void Divide ( int a , int b, ref int quotient, ref int remainder)
{
	quotient = a/b;
	remainder = a%b;
}
```
하지만 C#은 out 키워드를 이용한 출력전용 매개변수를 제공해 더욱 안전한 방법으로 사용할 수 있습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CsharpStudy
{
    class Program
    {
        static void Divide(int x, int y, out int quotient, out int remainder)
        {
            quotient = x / y;
            remainder = x % y;
        }
 
        static void Main(string[] args)
        {
            int x = 5;
            int y = 3;
            int quo, rem;
            Divide(x, y, out quo, out rem);
            Console.WriteLine("quo: {0} , rem: {1}", quo, rem); 
            // quo : 1, rem : 2
        }
    }
}

```


out 키워드를 사용할 경우

1. 메소드가 out 변수에 값을 저장하지 않을 경우 컴파일러가 에러를 발생합니다.
2. 호출된 메소드에서는 입력된 out 매개변수를 읽을 수 없고, 오직 쓰기만 가능합니다.(다른 용도로 사용되는 것을 금지합니다)

컴파일러가 에러를 발생한다는 것은 긍정적인 일입니다. 그 이유는 프로그래머에게 쉽게 에러를 고칠 수 있게 하지만, 런타임 오류는 프로그래머의 논리력으로 추적하여 고쳐야 하기 때문입니다.

### 3.1 Method Overloading

메소드 오버로딩은 하나의 메소드 이름에 여러가지 구현을 overloading(과적) 하는 것입니다.

오버로딩을 할 경우 비슷한 기능을 하는 메소드를 매개 변수의 자료형이나 개수 등을 보고 여러가지 메소드 중에서 컴파일을 할때 컴파일러가 실행할 메소드를 선택하기 때문에, 프로그램의 성능 저하도 없을 뿐더러 한가지 메소드 이름으로 비슷한 기능의 메소드를 전부 묶을 수가 있습니다.

프로그래밍을 하다보면 클래스의 이름, 메소드의 이름 등 이름만 봐도 다른사람이 직관적으로 바로 알 수 있게 정하는 것이 아주 중요합니다. 이 때 유용하게 쓰입니다.


**가변길이 매개변수**

매개 변수의 수만 다른 같은 기능을 하는 메소드를 오버로딩 하고 싶을 때 사용할 수 있습니다.

메소드 오버로딩을 이용할 수도 있겠지만, 가변길이 매개변수는 수만 다른 경우 갯수만큼 메소드를 오버로딩 하는 것보다 한번에 형식은 같지만 변수의 개수가 정해져있는 것이 아닐 경우 가변길이 매개변수가 유용하게 쓰일 수 있습니다.

예를 들면 모든 수를 합하는 Sum 메소드를 가변길이 매개변수를 이용하여 만들어 보겠습니다.
```
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
  
namespace CsharpStudy
{
    class Program
    {
        static int Sum(params int[] args)
        {
            int sum = 0;
            foreach(int num in args)
            {
                sum += num;
            }
            return sum;
        }
 
        static void Main(string[] args)
        {
            int result1 = Sum(2, 3, 5);
            int result2 = Sum(2, 3, 5, 7);
            int result3 = Sum(2, 3, 5, 7, 9);
            Console.WriteLine("result1 : {0} result2: {1} result3: {2}", result1, result2, result3);
            // result1 : 10 result2: 17 result3 : 26
        }
    }
}
```

주의할 점은 순서에 상관없이 매개변수 이름에 할당하기 때문에 하나라도 사용할 경우 전부 명명된 매개변수로 값을 할당해줘야야 합니다.

**명명된 매개변수(Named Parameter)**

메소드를 호출할때 매개변수에 데이터를 넣을때 순서대로 지정합니다.

예를 들면 void Method(int a, int b, int c); 라는 메소드가 정의되어 있을때 Method(1,2,3); 로 호출하면 a,b,c 차례대로 값이 1,2,3이 들어가서 Method 기능을 수행합니다.

C#에서는 이런 방식외에 매개변수에 이름을 직접 명명하여 데이터를 할당할 수 있습니다.

매개 변수가 너무 많은 메소드를 사용할 때 어느 특정 매개변수에 어느 데이터를 할당 할때 유용합니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
  
namespace CsharpStudy
{
    class Program
    {
        static void ShowProfile(string name, int age)
        {
            Console.WriteLine("이름: {0}  나이: {1}", name, age);
        }
 
        static void Main(string[] args)
        {
            ShowProfile("철수",10); // 이름: 철수 나이: 10
            ShowProfile(name: "영희", age: 15); // 이름 : 영희 나이: 15
            ShowProfile(age: 20, name: "영수"); // 이름: 영수 나이: 20
        }
    }
}
```


**선택적 매개변수**

매개 변수에 디폴트 값을 넣어 매개변수를 전달하지 않을 경우 디폴트 값이 자동으로 할당됩니다.
명명된 매개변수와 함께 이용할 경우 매개변수가 많은 메소드에서 넣고 싶은 매개변수만 원하는 데이터를 쉽게 넣을 수 있기 때문에 유용하게 쓰입니다.

주의할 점은 메소드 오버로딩과 선택적 매개변수를 동시에 사용할 때의 모호함이 있으므로 같이 사용하면 안됩니다.
```
void Method(string str1="", string str2="");
void Method(string str1);
```
위와 같은 두 가지 메소드가 있을 경우
Method("abc"); 로 메소드 호출 할때 여러분이 컴파일러라면 어떤 함수를 호출해야 할지 판단이 되나요?

## 4. Class (클래스)

**객체지향 프로그래밍 (Object Oriented Programming)**

클래스를 이야기 하기전에, 객체지향이 무엇인지 먼저 짚고 가겠습니다. 

객체지향 프로그래밍은 모든 것을 객체 단위로 표현하는 프로그래밍 패러다임입니다.
이 방법으로 프로그래밍할 경우 프로그램이 단순화되고, 생산성과 신뢰성이 높은 시스템을 구축할 수 있다고 합니다.
시간이 지날수록 프로그래밍언어가 발전하면서 생산성이 아주 좋죠. 프로그래밍할 때의 아이디어(알고리즘)은 항상 중요하지만, 이 아이디어를 어떻게 단순화시켜 유지보수(확장성)를 얼마나 쉽게 할 수 있는가가 매우 중요하다고 생각합니다.

객체지향프로그래밍의 3대 특성은 은닉성(Encapsulation), 상속성(Inheritance), 다형성(Polymorphism)이 있습니다.


**클래스 (Class)**

클래스는 복합데이터 형식입니다. 데이터와 메소드를 묶은 또 하나의 데이터 형식인 것입니다.

클래스 안에 선언된 변수(데이터)들은 필드(Field) 라고 부릅니다.
클래스는 기본적으로 생성자(Constructor)와 소멸자(Destructor)가 존재합니다.

하지만, C#에서는 CLR의 가비지 컬렉티가 객체 소멸 시점을 판단해서 소멸자를 호출하기 때문에 사용하지 말것을 권합니다.

### 4.1 Encapsulation (은닉성)

**은닉성(Encapsulation) : 접근 한정자(Access Modifier)로 공개수준 결정하기**

클래스의 사용자에게 필요한 최소의 기능만 노출하고 내부를 감출 것을 요구합니다.
C#은 다음과 같은 5가지 한정자를 제공합니다.

| 접근 한정자 (Access Modifier) | 설명                                                                                                                                            |
|:-----------------------------:|-------------------------------------------------------------------------------------------------------------------------------------------------|
| public                        | 클래스의 내부/외부 모든 곳에서 접근할 수 있습니다.                                                                                              |
| protected                     | 클래스의 외부에서는 접근할 수 없지만, 파생 클래스에서는 접근이 가능합니다.                                                                      |
| private                       | 클래스의 내부에서만 접근할 수 있습니다. 파생 클래스에서도 접근이 불가합니다.                                                                    |
| internal                      | 같은 어셈블리에 있는 코드에 대해서만 public으로 접근할 수 있습니다.  다른 어셈블리에 있는 코드에서는 private 와 같은 수준의 접근성을 가집니다.  |
| protected internal            | 같은 어셈블리에 있는 코드에 대해서만 protected로 접근할 수 있습니다.  다른 어셈블리에 있는 코드에서는 private 와 같은 수준의 접근성을 가집니다. |

은닉성이라는 개념때문에 보통 필드를 private로 선언하고, public 인 GetData(), SetData() 형식의 메소드를 만들어 사용합니다. 아주 단순하고 반복적인 코딩이죠. 또 데이터를 얻고 쓰기 위해 메소드를 사용해야 하는 것이 불편합니다.

하지만 C#에서는 프로퍼티 (Property)를 사용합니다.

### 4.2 Property(프로퍼티)

**프로퍼티(Property) : 은닉성과 편의성 동시에 잡기**

프로퍼티는 데이터의 오염에 대해선 메소드처럼 안전하고, 데이터를 다룰 때는 필드와 같으므로 간편합니다.

```
class Account
{
	private int Money;
	public int GetMoney()
	{
		return this.Money;
	}
	public void SetMoney(int Money)
	{
		this.Money=Money;
	}
}
```

```
class Account
{
	private int money;
	public int Money
	{
		get { return money; }
		set { money= value; }
	}
}
```

```
class Account
{
	public int Money { get; set; }
}
```

위 세가지 코드는 전부 같은 역할을 합니다.

1번째 코드를 C#에서는 2번째 방식인 프로퍼티를 사용하고, 심지어 3번째처럼 자동 구현 프로퍼티라는 것을 사용합니다. 
그 뿐만 아니라, 첫번째 코드는 Money에 100을 set하기위해서 SetMoney(100); 읽기 위해서 GetMoney() 메소드를 이용하지만, 2번째와 3번째 같은 프로퍼티는 Money=100; 와 같이 프로퍼티를 변수처럼 사용하기만 하면 됩니다.

2번째 프로퍼티부터 보겠습니다.
value는 set 접근자의 암묵적 매개변수이므로 매개변수로 받은 값을 money에 할당합니다.
현재 get과 set이 있지만, 프로퍼티를 쓰기 전용, 읽기 전용으로 만들고 싶을 때는 각각 set 과 get만 정의하면 됩니다.

3번째는 자동 구현 프로퍼티라고 합니다.
프로퍼티도 계속 해서 필드마다 단순 반복으로 만들다 보니 C#은 자동적으로 내부에 필드를 구현해줍니다.
따라서 이와 같은 코드가 가능해졌습니다.

프로퍼티를 이용하여 객체를 생성할때 각 필드를 초기화하는 방법이 있습니다.
```
클래스이름 인스턴스 = new 클래스이름 ()
{
	프로퍼티1 = 값,
	프로퍼티2 = 값
}

```

코드에서 살펴보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class MyInfo
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public string Job { get; set; }
 
        public void WhoAmI()
        {
            Console.WriteLine("Name: {0}", Name); // Name : 김현진
            Console.WriteLine("Age: {0}", Age);  // Age : 0
            Console.WriteLine("Job : {0}", Job); // Job : 학생
        }
    }
   
    class Program
    {
        static void Main(string[] args)
        {
            MyInfo me = new MyInfo()
            {
                Name = "김현진",
                Job = "학생"
            };
            me.WhoAmI();
        }
    }
}

```

초기화 방법을 명명된 매개변수처럼 순서에 상관없이, 원하는 데이터만 초기화를 할 수 있습니다.
(C#에서 초기화하지 않은 변수는 디폴트 값으로 초기화됩니다)

### 4.3 Inheritance(상속성)

**상속성(Inheritance): 코드 재활용하기**

기반 클래스(base class)로 부터 필드, 메소드 등을 그대로 물려 받아 새로운 파생 클래스(derived class)를 만드는 것입니다.

this는 자기자신 객체를 가리키듯이, base는 기반 클래스를 가리킵니다. this() 생성자와 같이 base() 생성자도 마찬가지입니다.
파생클래스에서 base 키워드를 사용하지 않아도 상속받은 필드, 메소드 등이 노출되지만 (private가 아닐 경우) 명확하게 표현하는 것은 좋은 습관이므로 base 키워드를 사용하는 것을 권합니다.

참고로, C#에서는 죽음의 다이아몬드 문제(The Deadly Diamond of Death) 로 클래스에 대한 다중 상속을 지원하지 않습니다.

C#에서는 sealed 한정자로 클래스를 작성하게 되면 상속을 봉인할 수 있습니다. (해당 클래스를 상속할 경우 컴파일에러)

```
sealed class Base { ... }
class Derived : base  // 컴파일 에러
{ ... }
```

### 4.4 Polymorphism(다형성)

**다형성(Polymorphism) : 형변환(Casting)과 오버라이딩(Overriding)**

객체가 여러 형태를 가질 수 있음을 의미합니다.

파생클래스의 인스턴스는 기반클래스의 인스턴스로 사용할 수 있습니다. 이를 이용하기 위해서는 캐스팅을 해야하는데 C#에서는 안전한 캐스팅 방법으로 다음을 제공합니다.

| 연산자 |                                                                      설명                                                                      |
|:------:|:----------------------------------------------------------------------------------------------------------------------------------------------:|
| is     | 객체가 해당 형식에 해당하는지를 검사하여 그 결과를 bool 값으로 반환합니다.                                                                     |
| as     | 형식 변환 연산자와 같은 역할을 합니다. 다만 형변환 연산자가 변환에 실패하는 경우 예외를 던지는  반면에 as연산자는 객체 참조를 null로 만듭니다. |


기반 클래스에 있는 메소드를 파생 클래스에서 사용할 때 다른 기능을 하고 싶다면 오버라이딩(Overriding)을 할 수 있습니다.

즉 파생 클래스에서 기능이 바뀔 수 있기 때문에 재정의하는 것을 말합니다. 이 때 조건은 오버라이딩할 메소드가 virtual 키워드로 되어있어야 합니다.(안쓸 경우 컴파일 에러 발생하므로 이해하고만 있으면 됩니다.)


기반 클래스로 파생클래스들을 받아 파생클래스의 오버라이딩된 메서드들을 기반클래스에서 파생클래스로 다시 캐스팅할 필요 없이(알아서 객체를 인식하고) 호출할 수 있습니다. 단 오버라이딩되지 않은 메서드를 호출하면 기반 클래스에 있는 virtual을 그대로 호출합니다.

만약 기반 클래스에 있는 virtual이 구현할 필요가 없는 추상적인 내용이라면 abstract로 만들면 반드시 파생클래스는 오버라이딩하여 구현해야 합니다.



따라서 virtual로 메소드를 정의 한다는 것은 팀프로젝트 단위에서 여러명이서 개발을 진행할 때 이 기반클래스를 상속받아 사용할때 재정의하여 사용하라는 프로그래머의 지시가 될 수 있습니다.


상속을 봉인했던 것처럼 오버라이딩 또한 봉인할 수 있습니다. 파생클래스에서 오버라이딩하여 사용하여 정의하였습니다. 하지만 이 파생클래스를 다시 상속받아 사용할때 오버라이딩을 할 수 없도록 봉인하는 것입니다.

```
class Base
{
	public virtual void SealMe()
	{}
}

class Derived : Base
{
	public sealed override void SealMe()
	{}
}

class DerivedDerived : Derived
{
	public override void SealMe()   // 컴파일 에러
	{}
}

```

봉인 메소드는 파생 클래스의 작성자를 위한 배려입니다. 혹시라도 파생 클래스의 작성자가 오버라이딩 했을 경우 클래스의 다른 부분이 오작동할 가능성이 있다고 판단될 때 사용할 수 있습니다.

**상속성(Inheritance)과 다형성(Polymorphism) 코드로 이해하기**

모든 사람을 Human 객체로 생각해봅시다. 모든 사람은 전부 다 성격이 다르고, 개개인마다 개성이 있습니다.

축구선수 박지성, 야구선수 류현진, 영화배우 송강호 등을 모두 표현하기 위해 Jisung, Hyunjin, Gangho 라는 클래스를 만들어 필드(이름,나이 등)와 기능; 메소드(개개인 특징; 연기력,운동실력 등)를 정의 하는 것은 아주 비효율적입니다.

따라서 Human 이라는 객체를 기반으로 하고, 이를 상속받아 SoccerPlayer, BasebollPlayer, Actor의 클래스에 각각의 추가적인 기능(연기,운동) 등을 추가하거나 재정의하기만 하면 되는 것입니다. 그리고 이 객체를 사용할 때는, 모두 각각의 객체로 생각하는 것이 아니라 사람이라는 객체로 간주하여, 형변환을 통해 사람이라는 기반클래스로 파생클래스 전부를 컨트롤 할 수 있습니다.

이를 간략하게 코드로 요약해보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
  
namespace CsharpStudy
{
    class Human
    {
        string Name;
 
        public Human(string name="")
        {
            this.Name = name;
        }
 
        public void PrintMyName()
        {
            Console.WriteLine(Name);
        }
 
        public virtual void Play()
        {
            Console.WriteLine("Nothing");
        }
    }
 
    class SoccerPlayer : Human
    {
        public SoccerPlayer(string name="") : base(name)
        { }
 
        public override void Play()
        {
            Console.WriteLine("Soccer");
        }
 
        public void Training()
        {
            Console.WriteLine("Soccer Training");
        }
    }
 
    class Actor : Human
    {
        public Actor(string name="") : base(name)
        { }
 
        public override void Play()
        {
            Console.WriteLine("Action");
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("===1번째 방식===");
            Human human1 = new SoccerPlayer("박지성");
            human1.PrintMyName();
            // human1.Training(); 
            // human1은 Human Type이므로 SoccerPlayer의 인스턴스 및 메소드를 접근할 수 없다.
            human1.Play();
 
            Console.WriteLine("===2번째 방식===");
            Human human2 = new SoccerPlayer("박지성");
            SoccerPlayer Soccer2 = (SoccerPlayer)human2;
            Soccer2.PrintMyName();
            Soccer2.Training();  // ==> SoccerPlayer로 캐스팅 후 방식1을 해결할 수 있다.
            Soccer2.Play();
 
            Console.WriteLine("===3번째 방식===");
            Human human3 = new SoccerPlayer("박지성");
            SoccerPlayer Soccer3 = human3 as SoccerPlayer;
            Soccer3.PrintMyName();
            Soccer3.Training();
            Soccer3.Play();
 
            Console.WriteLine("===객체를 잘 모를 때 안전한 형변환1===");
            Human human4 = new Actor("송강호");
            Actor actor4;
            if (human4 is Actor) // Human 객체가 SoccerPlayer 형식임을 확인한 후 형변환
            {
                actor4 = (Actor)human4;
                actor4.PrintMyName();
                actor4.Play();
            }
 
            Console.WriteLine("===객체를 잘 모를 때 안전한 형변환2===");
            actor4 = human4 as Actor; // 형변환이 실패할 경우 null 반환
            if( actor4!= null)
            {
                actor4.PrintMyName();
                actor4.Play();
            }
        }
    }
}
```

**중첩 클래스 (Nested Class)**

중첩 클래스는 클래스안에 선언되어있는 클래스입니다. 

중첩 클래스는 자신이 소속되어 있는 클래스의 멤버를 자유롭게 접근가능합니다. 클래스 외부에 공개하고 싶지 않은 형식을 만들 고 싶을 때, 현재 클래스의 일부분처럼 표현하는 클래스를 만들고자 할때 사용할 수 있습니다. 다른 클래스의 private 멤버에도 마구 접근가능하여 은닉성을 무너뜨리기도 하지만, 장점을 훨씬 더 부각시킬 수 있다면 사용하는 것이 좋겠습니다.

**분할 클래스 (Partial Class)**

분할 클래스는 여러번에 나눠서 구현하는 클래스를 말합니다. 

클래스 하나를 개발하는 데도 여러명이 해야할 경우 다른 파일에서 정의해도 컴파일할 때 묶어서 하나의 클래스로 컴파일합니다. class 앞에 partial 키워드만 붙이면 됩니다. (물론, 클래스 이름은 같아야 합니다)

**확장 메소드 (Extension Method)**

기존 클래스의 기능을 확장하는 방법입니다. 

상속받아 기능을 추가하는 것이 아닌, 기존 클래스의 기능을 확장합니다.
```
public static class 클래스이름
{
	public static 반환형식 메소드이름 ( this 확장하고자하는 클래스 또는 형식 , 매개변수 . . .)
	{...}
}
```

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/04-1.PNG)

그림에서 처럼 기존 int 라는 클래스의 메소드들 외에 Square()가 확장된 것을 확인하실 수 있습니다.


**구조체(Structure)**

C#의 복합 데이터형식에는 클래스 말고도 구조체(Structure) 가 있습니다. 

Class 뿐만 아니라 C언어에서 자주 접하던 Struct도 자주 사용됩니다. 클래스와 구조체의 차이점을 보겠습니다.

|      특징     |             클래스            | 구조체                                                                              |
|:-------------:|:-----------------------------:|-------------------------------------------------------------------------------------|
| 키워드        | class                         | struct                                                                              |
| 형식          | 참조형식                      | 값 형식                                                                             |
| 복사          | 얕은 복사 (Shallow Copy)      | 깊은 복사 (Deep Copy)                                                               |
| 인스턴스 생성 | new연산자와 생성자 필요       | 선언만으로도 생성                                                                   |
| 생성자        | 매개변수 없는 생성자 선언가능 | 매개변수 없는 생성자 선언 불가능                                                    |
| 상속          | 가능                          | 모든 구조체는 System.Object 형식을 상속하는 System.ValueType 으로부터 직접 상속받음 |

가장 큰 차이점은 클래스는 참조 형식이고 구조체는 값 형식 입니다. 

이것이 무엇을 의미하냐면, 구조체의 인스턴스는 스택에 할당되고 사용이 끝나면 즉시 메모리 상에서 사라집니다. 힙을 사용하지 않기 때문에 성능 상에서 많은 이점을 가질 수 있습니다. 아무리 컴퓨터 메모리가 커졌다고 해도, 최적화 문제는 항상 고려해야 합니다. 예를 들면 3차원 그래픽을 구현하는 데 있어서 백만개의 점의 데이터를 갖고 있다고만 해도 클래스를 사용하는 것과 구조체를 사용하는데 많은 성능 상의 차이가 발생합니다.

참고로 C#에서는 변수를 선언한 후 초기화 하지 않을 경우 기본값으로 CLR이 자동으로 초기화해줍니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
  
namespace CsharpStudy
{
    struct Point3D
    {
        public int X;
        public int Y;
        public int Z;
 
        public Point3D(int X, int Y, int Z)
        {
            this.X = X;
            this.Y = Y;
            this.Z = Z;
        }
 
        public override string ToString() // System.Object 를 항상 상속받습니다.
        {
            return string.Format("({0},{1},{2})", X, Y, Z);
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            Point3D point1;  // 선언만으로도 인스턴스 생성합니다.
            point1.X = 10;
            point1.Y = 20;
            point1.Z = 30;
            Console.WriteLine(point1.ToString()); // <10, 20, 30>
 
            Point3D point2 = new Point3D(11, 21, 31); // 생성자를 이용하여 인스턴스 생성도 가능합니다.
            Point3D point3 = point2; // 구조체는 깊은 복사가 이루어집니다.
            point3.Z = 50;
 
            Console.WriteLine(point2.ToString()); // <11, 21, 31>
            Console.WriteLine(point3.ToString()); // <11, 21, 50>
        }
    }
}
```

## 5. Interface (인터페이스)

클래스의 선언부 역할을 합니다.

메소드, 이벤트, 인덱서, 프로퍼티만을 가질 수 있습니다.

구현부가 없기 때문에 당연히 인스턴스를 생성할 수 없습니다.
클래스는 인터페이스를 상속받아 인터페이스의 모든 메소드를 구현해야만 사용할 수 있습니다.

말 그대로, 클래스의 인터페이스가 되는 것입니다.
프로그래밍 할때 구조를 그린 후 인터페이스를 만들면 팀 단위 프로젝트도 수월할 것이고, 생각을 단순화하기에 적합하겠습니다. 

사용방법은 다음과 같습니다.
```
interface 인터페이스이름
{
	반환형식 메소드이름1 (매개변수);
	반환형식 메소드이름2 (매개변수);
}
```

```
using System;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
  
namespace CsharpStudy
{
    interface IMonitor
    {
        void PowerButton();
        void InputDevice(int Device);
    }
 
    class Monitor : IMonitor
    {
        bool Power;
        int Devices;
 
        public Monitor()
        {
            this.Power = false;
            this.Devices = 0;
        }
 
        public void PowerButton()
        {
            if (Power)
            {
                Power = false;
                Console.WriteLine("Off");
            }
            else
            {
                Power = true;
                Console.WriteLine("On");
            }
        }
 
        public void InputDevice(int Device)
        {
            if (Power)
            {
                this.Devices = Device;
 
                switch (this.Devices)
                {
                    case 0:
                        Console.WriteLine("TV");
                        break;
                    case 1:
                        Console.WriteLine("Computer");
                        break;
                }
            }
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            IMonitor imonitor = new Monitor();
            imonitor.PowerButton();
            imonitor.InputDevice(1);
        }
    }
}
```

**인터페이스를 상속하는 인터페이스**

인터페이스를 상속할 수 있는 것은 클래스 뿐만이 아니라 구조체와 인터페이스도 인터페이스를 상속받을 수 있습니다.

보통 상속하려는 인터페이스가 소스코드가 아닌 어셈블리로 제공될 경우, 상속하려는 인터페이스의 소스코드를 가지고 있어도 이미 이 인터페이스를 상속하여 사용하는 클래스가 있어 수정할 수 없는 경우에는 인터페이스를 상속받아 수정하여 사용할 수 있습니다.
C#에서는 클래스에 대한 다중상속을 지원하지 않지만, 인터페이스는 죽음의 다이아몬드 문제가 발생하지 않으므로 인터페이스를 다중 상속받을 수 있습니다.

### 5.1 abstract class(추상클래스)

추상클래스는 인터페이스와 클래스 사이의 개념이라고 보면 되겠습니다.

추상클래스는 구현부를 가질 수 있으나 인터페이스를 만들지 못합니다. 또, 추상 메소드(abstract method)를 가질 수 있습니다.
추상 메소드는 인터페이스의 메소드처럼 선언부만 가진 메소드입니다. 따라서, C# 컴파일러는 추상 메소드가 private가 아닌 그 외에 접근한정자로 수식할 것을 요구합니다.

위의 인터페이스 코드를 추상클래스 코드로 바꾸어 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
  
namespace CsharpStudy
{
    abstract class AbsMonitor
    {
        protected bool Power;
        protected int Devices;
         
        public AbsMonitor()
        {
            this.Power = false;
            this.Devices = 0;
        }
 
        public void PowerButton()
        {
            if (Power)
            {
                Power = false;
                Console.WriteLine("Off");
            }
            else
            {
                Power = true;
                Console.WriteLine("On");
            }
        }
 
        abstract public void InputDevice(int Device);
    }
 
    class Monitor : AbsMonitor
    {    
        public override void InputDevice(int Device)
        {
            if (Power)
            {
                this.Devices = Device;
 
                switch (this.Devices)
                {
                    case 0:
                        Console.WriteLine("TV");
                        break;
                    case 1:
                        Console.WriteLine("Computer");
                        break;
                }
            }
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            AbsMonitor imonitor = new Monitor();
            imonitor.PowerButton();
        }
    }
}
```

추상클래스는 '파생클래스를 만들어 사용하세요. 

그리고, 주어진 추상메소드를 오버라이딩하여 사용해야 합니다' 라는 프로그래머의 메시지입니다.

## 6. Collection (컬렉션)

C#에서는 배열을 다음과 같이 사용합니다.

(2차원 배열의 예)
```
데이터형식 [ , ] 배열이름 = new 데이터형식[2차원길이, 1차원길이];
```

코드로 보면 다음과 같습니다.
```
int[,] array = new int[3,2]
{
	{1, 2},
	{2, 3},
	{3, 4}
};
```

또, 가변배열(Jagged Array)도 있습니다. 배열을 요소로 갖는 배열입니다.
```
데이터형식[][] 배열이름 = new 데이터형식[가변 배열 길이용량][]; 
```

코드로 보면 다음과 같습니다.
```
int[][] jaggedarray = new int[3][];
jaggedarray[0]= new int[5] {1,2,3,4,5};
jaggedarray[1]= new int[3] {10,20,30};
jaagedarray[2]= new int[2] {100,200};
```

**컬렉션(Collection)**

컬렉션이란, 같은 성격을 띠는 데이터의 모음을 담는 자료구조를 말합니다.

보통 같은 성격의 데이터의 묶음들을 배열로 만들어서 사용했지만, C#은 컬렉션이라는 개념으로 배열뿐만 아니라, ArrayList, Queue, Stack, Hashtable 등 여러가지 컬렉션 클래스를 제공합니다. (System.Collections)

이중에서 Hashtable만 사용해보겠습니다.
Hashtable은 Key와 Value가 쌍으로 이루어진 데이터를 다룰때 사용합니다.
자료구조에서도 배우겠지만, 해싱으로 아주 빠른 탐색속도를 자랑합니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Collections;
namespace CsharpStudy
{
    class Program
    {
        static void Main(string[] args)
        {
            Hashtable Ht = new Hashtable();
            Ht["하나"] = "One";
            Ht["둘"] = "Two";
            Ht["셋"] = "Three";
            
            Console.WriteLine("요소 직접 접근: {0}", Ht["셋"]);
             
            Console.WriteLine("==Hashtable의 모든 데이터 접근==");
            foreach(var value in Ht.Values)
            {
                Console.WriteLine(value);
            } // Two, One, Trre
 
            Console.WriteLine("==Hashtable의 모든 Key 접근==");
            foreach (var key in Ht.Keys)
            {
                Console.WriteLine(key);
            } // 둘, 하나, 셋
        }
    }
}
```

### 6.1 Indexer(인덱서)

인덱스를 이용하여 객체 내의 데이터에 접근하게 할 수 있습니다.

인덱서를 선언하는 형식은 다음과 같습니다.
```
class 클래스이름
{
	한정사 인덱서형식 this[형식 index]
    {
		get
		{
			// index를 이용하여 내부 데이터 반환
		}
		set
		{
		    // index를 이용하여 내부 데이터 저장
		}
	}
}
```

코드를 보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Collections;
namespace CsharpStudy
{
    class MyList
    {
        private int[] array;
 
        public MyList()
        {
            this.array = new int[3];
        }
 
        public int this[int index]
        {
            get
            {
                return array[index];
            }
            set
            {
                if(index >= array.Length)
                {
                    Array.Resize<int>(ref array, index + 1);
                    Console.WriteLine("array resized : {0}", array.Length);
                }
                array[index] = value;
            }
        }
 
        public int Length
        {
            get
            {
                return array.Length;
            }
        }
    
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            MyList mylist = new MyList();
 
            Console.WriteLine("==데이터 저장==");
            for(int i=0; i<5; i++)
            {
                mylist[i] = i;
            } // array resize : 4 , 5
 
            Console.WriteLine("==데이터 출력==");
            for (int i = 0; i < mylist.Length; i++) // foreach를 사용할 수 없습니다.
            {
                Console.WriteLine(mylist[i]);
            }    // 0 , 1, 2, 3, 4
        }
    }
}
```

위와 Mylist라는 객체에 대한 데이터를 인덱스로 접근할 수 있게 만들었습니다.
하지만, 조금만 생각해보면 foreach문은 불가능하다는 사실을 깨닫습니다. 그 이유는
Mylist라는 객체만 보고 요소하나하나를 어떻게 판단할 것이며, 어떻게 순회할지에 대한 약속이 전혀 없기 때문입니다.

그렇다면 foreach문이 가능한 객체는 어떻게 만들 수 있을까요?

### 6.2 IEnumerable, IEnumrator

**foreach문이 가능한 객체만들기**

foreach문이 가능하기 위해서는 IEnumerable, IEnumerator 를 상속받아야 합니다.

즉, IEnumerable, IEnumerator 를 구현하면서 약속을 정해주어야하는 것입니다.

IEnumerable

|            메소드           |              설명              |
|:---------------------------:|:------------------------------:|
| IEnumerator GetEnumerator() | IEnumerator 형식의 객체를 반환 |

IEnumerator

|          메소드         |                                                                 설명                                                                 |
|:-----------------------:|:------------------------------------------------------------------------------------------------------------------------------------:|
| boolean MoveNext()      | 다음 요소로 이동합니다. 컬렉션의 끝을 지난 경우에는 false, 이동이 성공한 경우에는true를 반환합니다.                                  |
| void Reset()            | 컬렉션의 첫 번째 위치의 '앞'으로 이동합니다. 첫번째 위치가 0번째라면 -1번으로 이동합니다.  MoveNext()를 호출한 다음에 이루어집니다.  |
| Object Current { get; } | 컬렉션의 현재 요소를 반환합니다.

위 인터페이스를 상속받아 구현해보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Collections;
namespace CsharpStudy
{
    class MyList : IEnumerable , IEnumerator
    {
        private int[] array;
        int position = -1;
        public MyList()
        {
            this.array = new int[3];
        }
 
        public int this[int index]
        {
            get
            {
                return array[index];
            }
            set
            {
                if(index >= array.Length)
                {
                    Array.Resize<int>(ref array, index + 1); 
                    Console.WriteLine("array resized : {0}", array.Length);
                }
                array[index] = value;
            }
        }
 
        public object Current
        {
            get
            {
                return array[position];
            }
        }
 
        public void Reset()
        {
            position = -1;
        }
 
        public bool MoveNext()
        {
            if( position == array.Length -1)
            {
                Reset();
                return false;
            }
 
            position++;
            return (position < array.Length);
        }
        public IEnumerator GetEnumerator()
        {
            for(int i=0; i <array.Length; i++)
            {
                yield return (array[i]);
            }
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            MyList mylist = new MyList();
 
            Console.WriteLine("==데이터 저장==");
            for(int i=0; i<5; i++)
            {
                mylist[i] = i;
            }
 
            Console.WriteLine("==데이터 출력==");
            foreach(var item in mylist) // foreach가 가능해졌습니다.
            {
                Console.WriteLine(item);
            }    
        }
    }
}
```

## 7. Exception (예외처리)

프로그래밍을 하다보면 수많은 예외상황들을 접하게 됩니다.

C#은 여러가지 예외클래스를 제공합니다.(DivideByZeroException, IndexOutOfRangeException, NullReferenceException 등)
여러가지 예외(Exception)가 발생했을 때 이 예외로 인해 프로그램이 종료되지 않고 다시 제대로 흘러가도록 예외마다 적절한 대처를 해주어야 합니다.

먼저, 한가지 예외를 발생시키고 설명하겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] Numbers = new int[5] { 1, 2, 3, 4, 5 };
 
            for(int i=0; i<6; i++)
            {
                    Console.WriteLine(Numbers[i].ToString());
            }
        }
    }
}
```
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/07-1.PNG)

위와 같이 잘못된 인덱스를 통해 접근하려하면 문제의 상세정보를 IndexOutOfRangeException의 객체에 담은 후 Main() 메소드로 던집니다. 여기서 예외처리를 하지 않았기 때문에 Main() 메소드는 다시 CLR에게 던집니다.

CLR이 '인덱스가 배열 범위를 벗어났습니다.'는 문구를 띄우면서 프로그램이 강제종료 되는 모습을 보실 수 있습니다.

위의 메시지는 CLR이 예외처리를 하라고 프로그래머한테 메시지를 보낸 것입니다. (이것도 일종의 예외처리겠지요.)

즉, 프로그래머가 예외처리를 하지 않았기 때문에 프로그램은 강제종료가 됩니다.

 
**예외처리(Exception Handling)**

예외처리는 if~else로도 전부 처리할 수 있습니다. 하지만, 예외에 대한 대처인지, 실제 문제처리하는 코드인지, 가독성도 좋지 않을 뿐더러 예외가 여러가지일때 무슨 예외상황인지도 파악하기가 어렵습니다. 또, 같은 예외가 여러군데에서 발생하면 일일이 다 처리해야합니다. 하지만 C#에서 예외처리문을 사용할 경우에는 위의 문제가 전혀 발생하지 않습니다. 

 
C#에서 예외처리는 try~catch 문을 이용합니다.
```
try
{
	//실행코드
}
catch (예외 객체1)
{
	//예외1에 대한 처리
}
catch (예외 객체2)
{
	//예외2에 대한 처리
}
finally
{
	// 반드시 실행되는 코드
}
```

위에서 발생했던 예외에 대한 처리를 해보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] Numbers = new int[5] { 1, 2, 3, 4, 5 };
 
            for(int i=0; i<6; i++)
            {
                try
                {
                    Console.WriteLine(Numbers[i].ToString());
                }
                catch (IndexOutOfRangeException e)
                {
                    Console.WriteLine("예외메시지 : {0}", e.Message);
                    Console.WriteLine("예외가 발생한 곳(namespace): {0}", e.Source);
                    Console.WriteLine("예외가 발생한 곳(method): {0}", e.TargetSite);
                    Console.WriteLine("예외가 발생한 곳(line): {0}", e.StackTrace);
                }
            }
 
            Console.WriteLine("예외 상황이 끝난 후..");
        }
    }
}
```
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/07-2.PNG)

예외클래스에는 예외에 대한 여러가지 정보가 담겨있습니다.

또한 예외처리를 할 경우 프로그램이 종료되지 않고 다음 코드가 정상적으로 작동되는 것을 확인하실 수 있습니다.

try블록에서 자원해제와 같은 중요한 코드를 미처 실행하지 못한 상태로 예외를 발생시키게 된다면, 이는 곧 버그를 만드는 원인이 됩니다. 예를 들어 DB Connection을 닫는 코드를 실행하지 못할 경우에는 사용할 수 있는 커넥션이 점점 줄어 DB에 연결할수 없는 상태에 도달할 수 있습니다. 따라서 finally 절을 지원합니다. finally 절은 try절이 실행된다면 어떤 경우에라도 실행됩니다. 심지어 return 문이나 throw 문이 사용되도 finally 절은 반드시 실행됩니다.


**System.Exception Class**

C#에서 모든 예외 클래스는 반드시 이 클래스로부터 상속받아야 합니다.

즉, 상속 관계로 인해 모든 예외클래스는 System.Exception 형식으로 간주하여 catch절 하나면 모든 예외를 다 받을 수도 있습니다. 하지만 예외마다 다른 대처를 해야한다면, 프로그래머는 예외상황에 따라 맞는 코드를 작성해야 합니다.

예외처리는 깊게 생각하여 정확히 처리해야합니다. 대충 try~catch문을 사용했다가는 프로그램이 흘러가면서 버그가 발생하는데도 프로그램이 종료되지 않아 버그를 찾기가 매우 어려워집니다.


**사용자 정의 예외 클래스 만들기**

C#에서는 모든 예외 객체는 System.Exception 클래스로부터 파생되어야 합니다. 

이를 상속하기만 하면 프로그래머가 직접 새로운 예외 클래스를 만들수 있습니다. C#에서는 100가지 넘는 예외 클래스를 제공하지만, 사용자가 직접 예외를 발생하고 싶은 경우도 있습니다.

예를 들면 회원가입 할때 비밀번호는 8자리 이상을 입력해야 된다거나, 영문을 섞어야 할때 프로그래머는 이를 지키지 않을 경우 예외를 발생시킬 수도 있습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace CsharpStudy
{
    class ShortPasswordException : Exception
    {
        public ShortPasswordException(string message) : base(message)
        {
 
        }
 
        public string Range
        {
            get;
            set;
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            do
            {
                Console.WriteLine("비밀번호를 입력하세요!");
                string Password = Console.ReadLine();
                try
                {
                    if (Password.Length < 8)
                    {
                        throw new ShortPasswordException("비밀번호가 너무 짧습니다")
                        {
                            Range = "8자리 이상"
                        };
                    }
                    else
                    {
                        break;
                    }
                }
                catch (ShortPasswordException e)
                {
                    Console.WriteLine("예외메시지: {0}", e.Message);
                    Console.WriteLine("예외발생한곳: {0}", e.StackTrace);
                    Console.WriteLine("가능범위: {0}", e.Range);
                }             
            } while (true);
        }
    }
}
```
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/07-3.PNG)

## 8. Delegate, Event
### 8.1 Delegate (델리게이트)

델리게이트는 메소드에 대한 참조입니다. 즉, 델리게이트는 하나의 형식(type) 입니다.

델리게이트는 인스턴스 메소드, 정적메소드 모두 참조가능합니다.
프로그래밍을 할때 매개변수에 값을 넘겨 쓸모있는 메소드를 만들었습니다. 델리게이트는 값이 아닌 '코드' 자체를 넘기고 싶을때 사용할 수 있습니다.

사용방법은 다음과 같습니다.
```
한정자 delegate 반환형식 델리게이트이름 (매개변수_목록);
```

어떤 데이터를 정렬하고자 할때  오름차순이나 내림차순, 중앙부터 가까운 순으로 정렬 등, 프로그래머가 원하는 정렬방식을 사용하도록 메소드만 건네주기만 하면 됩니다.

코드를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        delegate int Compare(int number1, int number2);
 
        static int AscendCompare(int number1, int number2)
        {
            if (number1 > number2)
                return 1;
            else if (number1 == number2)
                return 0;
            else
                return -1;
        }
 
        static int DescendCompare(int number1, int number2)
        {
            if (number1 < number2)
                return 1;
            else if (number1 == number2)
                return 0;
            else
                return -1;
        }
 
        static void ExchangeData(ref int number1, ref int number2)
        {
            int Temporary=number1;
            number1 = number2;
            number2 = Temporary;
        }
 
        static void BubbleSort(int [] Data , Compare Comparer)
        {
            for (int j = 0; j < Data.Length; j++)
            {
                for (int i = 0; i < Data.Length - 1 - j; i++)
                {
                    if (Comparer(Data[i], Data[i + 1]) > 0)
                    {
                        ExchangeData(ref Data[i], ref Data[i + 1]);
                    }
                }
            }
        }
 
        static void Main(string[] args)
        {
            int[] DataSet = new int[]{ 10, 5, 2, 9, 8, 1, 6, 3, 2, 5 };
 
            BubbleSort(DataSet, AscendCompare);
            Console.WriteLine("==Sorted by Ascend==");
            foreach(int num in DataSet)
            {
                Console.Write(" {0}", num);
            } // 1 2 2 3 5 5 6 8 9 10
            
            Console.WriteLine(Environment.NewLine+"==Sorted by Descend==");
            BubbleSort(DataSet, DescendCompare);
            foreach (int num in DataSet)
            {
                Console.Write(" {0}", num);
            } // 10 9 8 6 5 5 3 2 2 1
        }
    }
}
```

### 8.2 Delegate Chain (델리게이트 체인)

**델리게이트 체인(Delegate Chain), 익명메소드 (Anonymous Method)**

델리게이트 하나가 여러개의 메소드를 동시에 참조할 수 있습니다. 체인처럼 델리게이트를 연달아 등록하여, 순서대로 참조된 함수들을 호출합니다.

델리게이트를 등록할때는 += 연산자 또는 Delegate.Combine() 메소드를 이용할 수 있고, 체인을 끊고 싶을 때는 -= 연산자 또는 Delegate.Remove() 메소드를 이용하면 됩니다.

익명메소드는 델리게이트가 참조할 메소드가 필요한데, 이 메소드가 다시 사용할 일이 없다고 판단될때 이름이 없는 메소드를 참조하면 됩니다.

익명 메소드는 다음과 같이 만들 수 있습니다.
```
delegate (매개변수_목록)
{
	//실행코드
}
```

델리게이트 체인과, 익명 메소드 예제입니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        delegate void DelegateChains();
   
        static void Print1()
        {
            Console.WriteLine("Welcome");
        }
        static void Print2()
        {
            Console.WriteLine("To");
        }
        static void Print3()
        {
            Console.WriteLine("C#");
        }
 
        static void Main(string[] args)
        {
            Console.WriteLine("==체인 연결==");
            DelegateChains chaincall = new DelegateChains(Print1);
            chaincall += Print2;
            chaincall += Print3;
            chaincall(); // Welcome, to, C#
 
            Console.WriteLine("== 체인 끊기 ==");
            chaincall -= Print1;
            chaincall -= Print3;
            chaincall+=
                delegate()
                {
                    Console.WriteLine("Anonymous Method call");
                };
            chaincall(); // To , Anonymous Method Call
        }
    }
}
```

### 8.3 Event(이벤트)

프로그래밍을 할때 보통 순차적으로 진행되고는 했습니다. 하지만 어떤 일이 생겼을 때 이를 알려주는 객체가 필요할 때가 있습니다. 이 객체를 만들 때 사용하는 것이 이벤트(Event) 입니다.

이벤트는 어떤 일이 일어났을 때, 그 때 실행되는 코드입니다.

이벤트기반 프로그래밍(Event-driven programming)은 마우스를 움직이고, 클릭하고, 키보드를 입력하는 등 사용자가 명령하는 것에 대해서 프로그램이 그에 맞는 반응을 하는 것처럼 이벤트 기반으로 만들어진 프로그래밍 방식입니다.

이벤트는 델리게이트를 event 한정자로 수식해서 만듭니다. 그 과정은 다음과 같습니다.

1. 델리게이트를 선언합니다. (이 델리게이트는 클래스 안과 밖 아무곳에나 선언해도 됩니다.)
2. 클래스내에 1번에서 선언한 델리게이트의 인스턴스를 event 한정자로 수식하여 선언합니다.
3. 이벤트 핸들러를 작성합니다. 이벤트 핸들러는 1번에서 선언한 델리게이트와 일치하는 메소드여야 합니다.
4. 클래스의 인스턴스를 생성하고 이 객체의 이벤트에 3번에서 작성한 이벤트 핸들러를 등록합니다.
5. 이벤트가 발생하면 이벤트 핸들러가 호출됩니다.


이벤트 예제입니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        delegate void EventHandler(string message);
 
        class Notifier
        {
            public event EventHandler SomethingHappened;
 
            public void DoSomething(int number)
            {
                if (number == 5)   // 숫자가 5일때 이벤트가 발생한다고 생각합니다.
                {
                    SomethingHappened("이벤트 발생! (number 값:}" + number.ToString());
                }
            }
        }
 
        static void Main(string[] args)
        {
            Notifier notifier = new Notifier();
            notifier.SomethingHappened += MyHandler;  // 발생시킬 이벤트를 등록한다.
 
            for (int i = 0; i < 30; i++)  // 프로그램이 진행된다.  ( 대기상태에서 숫자 5일때 등록한 이벤트가 발생하게 된다. )
                notifier.DoSomething(i);
           // 이벤트 발생 ! <number 값:> 5
        }
 
        static void MyHandler(string message)
        {
            Console.WriteLine(message); 
        }
    }
}
```

이벤트 처리기에 등록하지 않아도 컴파일 에러가 발생하지 않습니다. 따라서 이벤트를 만들었을 때 초기화를 하지 않으면, 이벤트가 발생해도 아무런 일이 일어나지 않은 것처럼 나오기 때문에 항상 초기화하는 습관을 갖는 것이 좋을 듯 합니다.

이벤트는 델리게이트에 event를 수식해서 선언한 것에 불과합니다. 하지만 이벤트가 델리게이트와 가장 큰 차이점은 이벤트는 외부에서 직접 사용할 수 없다는 데 있습니다. 이벤트는 public 한정자로 선언되어 있어도 자신이 선언되어 있는 클래스 외부에서는 호출이 불가능합니다. 이는 이벤트 기반 프로그래밍을 할 때 안정성을 추구할 수 있게 합니다.

예를 들어 네트워크 상태변화에 대한 사건을 알리는 클래스를 만들었다고 하면, 클래스 내부에서 객체를 감시하며 네트워크 상태를 체크하지만, 클래스 외부에서 네트워크 상태 변화 이벤트를 줄 수 있다면, 이미 네트워크 상태는 신뢰할 수 없게 됩니다.

따라서, 델리게이트는 콜백용도로 사용하고, 이벤트는 객체상태변화나 사건의 발생을 알리는 용도로 사용해야 합니다.

## 9. Lambda Expression (람다식)

람다식이라는 함수형 언어에서 사용하는 기법들이 있습니다.
C#에서는 람다식이라는 함수형 언어를 사용할 수 있도록 람다식을 지원합니다.

람다식은 익명 메소드(Anonymous Function)를 좀 더 쉽게 만들기 위해 사용합니다.

식(Expression) 형식의 람다식 선언방식은 다음과 같습니다.
```
(매개변수_목록)  =>  식
```

```
delegate (int a, int b)
{
	return a+b;
}
```
```
(int a, int b) => a+b;
```
```
(a,b) => a+b;
```

위 세가지 방법은 모두 같은 익명메소드를 의미합니다.

첫번째 델리게이트를 람다식을 이용해 두번째 방식처럼 만들 수 있으며, 세번째 방식은 C#에서 형식 유추 (Type Inference) 기능을 제공하기 때문에 매개변수 형식을 제거할 수 있습니다.


문(Statement) 형식의 람다식의 선언 방식은 다음과 같습니다.
```
(매개변수_목록) =>
{
	//코드
}
```

람다식 예제를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        delegate int Method(int a, int b);
 
        static void Main(string[] args)
        {
            Method Add= (a, b) => a+b;
            Console.WriteLine(Add(3, 4)); // 7
 
            Method Minus = (a, b) =>
                {
                    Console.WriteLine("{0} - {1} 의 결과는?", a, b);
                    return a - b;
                };
            Console.WriteLine(Minus(5, 3)); // 5 - 3 의 결과는? 2
            
        }
    }
}
```
위와 같이 익명 메소드를 만들기 위해 별개의 델리게이트를 선언하는 번거로운 일이 있어서 C# 은 Func 델리게이트와 Action 델리게이트를 지원합니다.
Func 델리게이트는 결과를 반환하는 메소드를 참조하기 위해, Action 델리게이트는 반환형식이 없는 메소드 참조를 위해서 사용합니다.

## 10. LINQ (Language INtergrated Query)

C#언어에 통합된 데이터 질의기능이 있습니다. 데이터베이스에서 날리는 쿼리 정도 생각하시면 되겠습니다.

53개의 표준 LINQ 연산 메소드 중에서 쿼리식을 지원하는 것은 11가지 입니다. 쿼리식은 표준 LINQ 연산 메소드를 호출하는 원리로 이루어져 있기때문에, 쿼리식이 부족하다 싶을때는 함수호출을 이용하는 것도 하나의 방법입니다. 

여기에서는 몇가지 쿼리들만 정리하겠습니다.  [자세한 내용은 MSDN을 참고하세요.][link]
[link]: https://msdn.microsoft.com/en-us/library/bb308959.aspx


가장 기본이 되는 쿼리입니다.
* from  : 쿼리식의 대상이 될 데이터 원본과 안에 들어있는 각 요소 데이터를 나타내는 범위 변수를 지정해주어야 합니다. from의 데이터 원본은 IEnumerable<T> 인터페이스를 상속하는 형식이어야 합니다. 
* where : 해당 조건에 부합하는 데이터만을 걸러낼때 사용하는 연산자 입니다.  
* orderby : 데이터의 정렬을 수행하는 연산자입니다.
* select : 최종 결과를 추출합니다.

다음과 같이 쿼리식을 작성하는 것은 내부적으로 LINQ 표준 메소드를 호출하는 것과 동일합니다.

LINQ 쿼리식

```
var profileList = from profile in Profiles
	where profile.Height < 175
	orderby profile.Height
	select
	new
	{
 		 Name = Profile.Name,
 		 InchHeight = profile.Height*0.393
	};
```

LINQ 메소드 호출 방식
```
var profileList = Profiles.
	Where ( profile=> profile.Height < 175).
	Orderby ( profile => profile.Height).
	Select ( profile =>
	new
	{
        Name = Profile.Name,
        InchHeight = profile.Height*0.393
	});
```

LINQ 예제를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        class Profile
        {
            public string name { get; set; }
            public int height { get; set; }
        }
 
        static void Main(string[] args)
        {
            Profile[] profiles = new Profile[5]
           {
               new Profile(){ name="정우성", height=186 },
               new Profile(){ name="김태희", height=158 },
               new Profile(){ name="고현정", height=172 },
               new Profile(){ name="이문세", height=178 },
               new Profile(){ name="하동훈", height=171 }
           };
 
            var pro = from profile in profiles  // profiles 원본에서 각 요소 profile 객체에서
                      where profile.height < 175 // profile.height 값이 175 이하인 데이터를
                      orderby profile.height descending // descending 으로 정렬한다.
                      select profile;            // 정렬 결과의 profile 객체의 list를 추출한다.
 
            foreach(var profile in pro)
            {
                Console.WriteLine("{0} , {1}", profile.name, profile.height);
            } 
        }
    }
}
```

**데이터 분류하기**

다음 쿼리식을 통해 데이터를 분류할 수 있습니다.
```
group A by B into C
```

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        class Profile
        {
            public string Name { get; set; }
            public int[] Score { get; set; }
        }
 
        static void Main(string[] args)
        {
            Profile[] profiles = new Profile[5]
           {
               new Profile(){ Name="김철수", Score=new int[]{77,39,55} },
               new Profile(){ Name="김영희", Score=new int[]{89,80,40} },
               new Profile(){ Name="이상훈", Score=new int[]{82,60,82} },
               new Profile(){ Name="이세상", Score=new int[]{95,88,91} },
               new Profile(){ Name="박철민", Score=new int[]{65,59,72} }
           };
 
            var grouping = from profile in profiles
                           group profile by profile.Score[0] < 70 into gr
                           select new { Groupkey = gr.Key, Profile = gr };
 
            foreach (var Group in grouping)
            {
                if(Group.Groupkey) // by에 의해 분류된 것은 Key값이 True를 갖는다.
                {
                    Console.WriteLine("원하는 데이터"); // 65
                }
                else
                {
                    Console.WriteLine("나머지 데이터");  // 77 89 82 95
                }
 
                foreach (var profile in Group.Profile)
                {
                    Console.WriteLine("{0}", profile.Score[0]);
                }
            } 
        }
    }
}
```

**데이터 연결하기**

조인을 통해 두 데이터 원본을 연결할 수 있습니다.
 
**내부조인(Inner Join)**
두 데이터 원본이 일치하는 데이터만 연결하여 추출합니다.
```
from a in A
join b in B on a.XX equals by b.YY
```
join 절의 on 키워드는 조인 조건을 수반합니다. 이때 조인 조건은 동등(Equality)만 허용됩니다.
equals라는 키워드 없이 동등연산자인 == 를 사용해도 됩니다.


**외부조인(Outer Join)**

내부조인은 두 데이터 원본이 일치하는 데이터만 연결하여 추출합니다. 일치하는 데이터가 있을 경우에만 추출하는 반면에
외부조인은 일치하는 데이터가 없으면 빈값을 채워 모두 연결하여 추출합니다.

방법은 내부조인을 진행한 후에 into 키워드를 통해 임시컬렉션에 저장하고, 이 임시 컬렉션에 대해서 DefaultIfEmpty 연산을 수행하여 조인결과에 빈값을 채워 넣습니다.

조인 방식에는 왼쪽조인(Left Join), 오른쪽 조인 (Right Join), 완전 조인(Both Join) 세가지가 있지만,
LINQ는 왼쪽조인만을 지원합니다. 

조인 예제를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace CsharpStudy
{
    class Program
    {
        class Profile
        {
            public string Name { get; set; }
            public int Height { get; set; }
        }
         
        class Product
        {
            public string Title { get; set; }
            public string Star { get; set; }
        }
 
        static void Main(string[] args)
        {
            Profile[] Profiles = new Profile[5]
            {
                new Profile() { Name="정우성" , Height=186},
                new Profile() { Name="김태희" , Height=158},
                new Profile() { Name="고현정" , Height=172},
                new Profile() { Name="이문세" , Height=178},
                new Profile() { Name="하하" , Height=171}
            };
 
            Product[] Products = new Product[6]
            {
                new Product() { Star="정우성" , Title="비트"},
                new Product() { Star="김태희" , Title="CF 다수"},
                new Product() { Star="김태희" , Title="아이리스"},
                new Product() { Star="이문세" , Title="붉은노을"},
                new Product() { Star="고현정" , Title="선덕여왕"},
                new Product() { Star="손예진" , Title="연애시대"}
            };
 
            var InnerJoinList = from profile in Profiles
                              join product in Products on profile.Name equals product.Star
                              select new
                              {
                                  Name = profile.Name,
                                  Work = product.Title,
                                  Height = profile.Height
                              };
 
            var OuterJoinList = from profile in Profiles
                                join product in Products on profile.Name equals product.Star into ps
                                from product in ps.DefaultIfEmpty(new Product() { Title = "Null" })
                                select new
                                    {
                                        Name = profile.Name,
                                        Work = product.Title,
                                        Height = profile.Height
                                    };
 
 
            Console.WriteLine("===== 내부 조인 결과 ====");
            foreach( var profile in InnerJoinList)
            {
                Console.WriteLine("이름: {0} 작품: {1} 키: {2} ", profile.Name, profile.Work, profile.Height);
            }
 
            Console.WriteLine(Environment.NewLine+"==== 외부 조인 결과 ====");
            foreach (var profile in OuterJoinList)
            {
                Console.WriteLine("이름: {0} 작품: {1} 키: {2} ", profile.Name, profile.Work, profile.Height);
            }      
        }
    }
}
```
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/10-1.PNG)

## 11.Thread, Task (쓰레드와 테스크)
### 11.1 Thread

프로세스는 실행 파일이 실행되어 메모리에 적재된 인스턴스입니다. 운영체제는 여러가지 프로세스를 동시에 실행할 수 있는 능력을 갖추고 있습니다. 즉 컴퓨터로 Youtube에서 노래를 들으면서 코딩을 할 수 있습니다.

그런데, 프로세스도 한번에 여러가지 작업을 수행할 수 있습니다. 쓰레드는 운영체제가 CPU 시간을 할당하는 기본 단위인데, 프로세스는 하나 이상의 쓰레드로 구성됩니다.

쓰레드의 장점

* 사용자 대화형 프로그램에서 응답성을 높일 수 있다.
 (프로그램이 무슨 일을 하고 있을 때 대기 할 필요없이 다른 일을 진행할 수 있다)
* 멀티 프로세스 방식에 비해 멀티 스레드 방식이 자원 공유가 쉽다.
 (프로세스끼리 데이터를 교환할 때 IPC;Inter Process Communication을 이용해야 하지만, 쓰레드는 코드 내의 변수를 같이 사용하기만 하면 된다)
* 쓰레드를 사용하면 이미 프로세스에 할당된 메모리와 자원을 그대로 사용한다.
  (멀티 프로세스는 프로세스를 띄우기 위해 메모리와 자원을 할당하는 작업을 진행해야 한다)

쓰레드의 단점

* 멀티 쓰레드에서 자식 쓰레드가 문제가 생기면 전체 프로세스가 영향을 받게 된다.
(멀티 프로세스는 자식이 문제가 생기면 해당 프로세스만 죽습니다)
* 멀티 쓰레드 구조의 소프트웨어는 구현하기가 까다롭다.
(테스트가 어렵고 디버깅 또한 쉽지 않습니다)
* 쓰레드가 CPU를 사용하기 위해서는 작업간 전환 (Context Switching) 을 해야 한다.
(자주 작업 간 전환을 하기 되면 성능이 저하된다)

**쓰레드의 상태**

.NET Framework 의 ThreadState는 다음과 같습니다.

|      상태     |                                                                                                                                                                           설명                                                                                                                                                                           |
|:-------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Unstarted     | 쓰레드 객체를 생성한 후 Thread.Start() 메소드가 호출 되기 전의 상태입니다.                                                                                                                                                                                                                                                                               |
| Running       | 쓰레드가 시작하여 동작 중인 상태입니다.  Unstarted 상태의 쓰레드를 Thread.Start() 메소드를 통해 이 상태로 만들 수 있습니다.                                                                                                                                                                                                                              |
| Suspended     | 쓰레드의 일시 중단 상태입니다.  쓰레드를 Thread.Suspend() 메소드를 통해 이 상태로 만들 수 있으며, Suspended 상태인 쓰레드는 Thread.Resume() 메소드를 통해 다시 Running 상태로 만들 수 있습니다.                                                                                                                                                          |
| WaitSleepJoin | 쓰레드가 블록(Block)된 상태입니다.  쓰레드에 대해 Monitor.Enter(), Thread.Sleep(), Thread.Join() 메소드를 호출하면 이 상태가 됩니다.                                                                                                                                                                                                                     |
| Aborted       | 쓰레드가 취소된 상태입니다.  Thread.Abort() 메소드를 호출하면 이 상태가 됩니다. Aborted 상태가 된 쓰레드는 다시 Stopped 상태로 전 환되어 완전히 중지됩니다.                                                                                                                                                                                              |
| Stopped       | 중지된 쓰레드의 상태입니다.  Thread.Abort() 메소드를 호출하거나 쓰레드가 실행 중인 메소드가 종료되면 이 상태가 됩니다.                                                                                                                                                                                                                                   |
| Background    | 쓰레드가 백그라운드로 동작되고 있음을 나타냅니다. Foreground 쓰레드는 하나라도 살아 있는 한 프로세스 가 죽지 않지만, Background는 여러개가 살아 있어도 프로세스가 죽고 사는 것에는 영향을 미치지 않습니다 하지만 프로세스가 죽으면 Background 쓰레드는 모두 죽습니다. Thread.IsBackground 속성에 true 값을 입력하면 쓰레드를 이 상태로 바꿀 수 있습니다. |


### 11.1 Thread LifeCycle

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/11-1.png)

쓰레드 실행 예제를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Threading;
 
namespace CsharpStudy
{
    class Program
    {
        static void DoSomething()
        {
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine("Thread : {0}", i);
                Thread.Sleep(250);
            }
        }
 
        static void ParametersDosomething(object num)
        {
            for(int i=0; i<(int)num; i++)
            {
                Console.WriteLine("ParametersThread : {0}", i);
                Thread.Sleep(250);
            }
        }
 
        static void Main(string[] args)
        {
            Thread thread = new Thread(new ThreadStart(DoSomething));
            thread.Start();
            thread.Join(); // thread 가 종료될 때 까지 대기.
 
            Thread thread2 = new Thread(new ParameterizedThreadStart(ParametersDosomething));
            thread2.Start(5);//매개변수를 갖는 쓰레드 실행하는 방법(object 매개변수만 넘길수 있다)
 
            for(int i=0; i<5; i++)
            {
                Console.WriteLine("Main : {0}", i);
                Thread.Sleep(500);
            }
        }
    }
}
```

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/11-2.PNG)

**쓰레드 종료하기**

쓰레드는 스스로 할일을 마치고 종료하는 것이 가장 좋겠지만, 쓰레드를 종료시켜야 할 경우가 있습니다.

Thread.Abort() 메소드로 가능하지만, 이는 쓰레드를 강제로 종료시켜버립니다. 즉, 도중에 작업이 강제로 종료되도 프로세스 자신이나 시스템에 전혀 영향이 없는 작업에 한해 사용하는 것이 좋습니다. 만약, 수행중인 작업이 시스템에 영향이 있을 거라 판단된다면 다음과 같이 쓰레드를 종료시켜야 합니다.

Thread.Interrupt() 메소드는 쓰레드가 Running State를 피해서 WaitJoinSleep State 에 들어갔을 때 ThreadInterruptedException 예외를 던져 쓰레드를 중지시킵니다. 따라서 절대로 중단되면 안되는 작업을 할 때 이렇게 안정성이 보장된 방법을 사용해야합니다.


쓰레드 종료 예제를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Threading;
 
namespace CsharpStudy
{
    class Program
    {
        static void DoSomething()
        {
            try
            {
                for (int i = 0; i < 5; i++)
                {
                    Console.WriteLine("Thread : {0}", i);
                    Thread.Sleep(250);
                }
            }
            catch(ThreadInterruptedException e)
            {
                Console.WriteLine(e);
            }
            finally
            {
                Console.WriteLine("====Clearing Resource===");
            }
        }
 
        static void Main(string[] args)
        {
            Thread thread = new Thread(new ThreadStart(DoSomething));
            thread.Start();
            
            for(int i=0; i<5; i++)
            {
                Console.WriteLine("Main : {0}", i);
                Thread.Sleep(500);
                if (i == 0)
                    thread.Interrupt();
            }
        }
    }
}
```

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/11-3.PNG)

### 11.3 쓰레드 간 동기화

각 쓰레드들은 여러가지 자원을 공유하는 경우가 많습니다. 쓰레드가 어떤 자원을 사용하고 있는데, 도중에 다른 쓰레드가 이 자원을 사용한다면 문제가 발생할 수 있습니다.

예를 들면 은행에서 돈을 인출해주려고 할때, ATM 기기에서, 휴대폰에서, 인터넷뱅킹으로, 각각 비슷한 시간에 전재산을 인출해달라고 요청한다면 은행이 3번 모두 전재산을 인출시킨다면 문제가 있겠지요.

예제로 자원을 공유하는 상황을 만들어보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Threading;
 
namespace CsharpStudy
{
    class Program
    {
        class Account
        {
            public int money = 1000;
 
            public void withdraw()
            {
                if (money <= 0)
                {
                    Console.WriteLine("잔액이 모자랍니다.");
                }
                else
                {
                    money -= 1000;
                }
            }
        }
 
        static void Main(string[] args)
        {
            Account account = new Account();
            Thread ATM = new Thread(new ThreadStart(account.withdraw));
            Thread Phone = new Thread(new ThreadStart(account.withdraw));
            Thread Internet = new Thread(new ThreadStart(account.withdraw));
 
            Console.WriteLine("ATM");
            ATM.Start();
            Console.WriteLine("Phone");
            Phone.Start();
            Console.WriteLine("Internet");
            Internet.Start();
        }
    }
}
```

위의 코드 결과가 잔액이 모자랍니다가 나올수도 있고 안나올수도 있습니다. 동시에 진행되어 세번 무사히 출금이 이루어 질수도 있는 것입니다.


따라서, 쓰레드들이 순서를 갖춰 자원을 사용할 수 있도록 동기화(Synchronization)을 해주어야 합니다. 자원을 한번에 하나의 쓰레드만 사용할 수 있도록 보장해야 합니다.

C# 에서는 쓰레드 간에 동기화하는 도구로 lock 키워드와 Monitor 클래스를 제공합니다.


**lock 키워드로 동기화하기**

한번에 한 쓰레드만 사용할 수 있는 크리티컬 섹션(Critical Section)인 코드영역을 만들어 주어야합니다.
C#에서는 lock 키워드로 감싸주기만 하면 크리티컬 섹션으로 바꿀 수 있습니다.

```
private readonly object thisLock= new object();
public void withdraw()
{
    lock(thisLock)   // 크리티컬 섹션영역이 됩니다. 한 쓰레드가 이 코드를 실행하면서
	{                // lock 블록이 끝나기 전까지 다른 쓰레드는 이 코드를 실행할 수 없습니다.
		if (money <= 0)
		{
        	Console.WriteLine("잔액이 모자랍니다.");
        }
        else
        {
			money -= 1000;
        }
}

```

lock 키워드는 사용하는 것 자체는 쉽습니다. 하지만, 쓰레드들이 lock 키워드를 만나 크리티컬 섹션을 생성하려고 할 때 이미 하나의 쓰레드가 사용 중이면 락을 얻을 수가 없습니다. 즉 계속 대기하는 상황이 벌어집니다. 이렇게, 소프트웨어의 성능이 크게 떨어집니다. 따라서 쓰레드의 동기화를 설계할 때 크리티컬 섹션을 반드시 필요한 곳에만 사용하는 것이 중요합니다.

또, lock 키워드의 매개변수로 사용하는 객체는 참조형이면 어느 것이든 쓸수 있지만, public 키워드 등을 통해 외부 코드에서도 접근할 수 있는 다음 세가지는 절대 사용하지 않기를 권합니다.

* this : 클래스의 인스턴스는 클래스 내부뿐만 아니라 외부에서도 자주 사용됩니다. lock (this)는 좋지 않습니다.
* Type 형식 : typeof 연산자나 object 클래스로부터 물려받은 GetType() 메소드는 코드 어느 곳에서나 특정 형식에 대한 Type객체를 얻을 수 있습니다. lock(typeof(SomeClass)) , lock(obj.GetType()) 은 좋지 않습니다.
* string 형식 : 절대 string 객체로 lock 하지마시기 바랍니다. lock("abc") 는 좋지 않습니다.


**Monitor 클래스로 동기화하기**

```
public void withdraw()
{
       lock(thisLock)
       {
           if (money <= 0)
           {
                 Console.WriteLine("잔액이 모자랍니다.");
           }
           else
           {
                 money -= 1000;
           }
       }
}
```

```
public void withdraw()
{
      Monitor.Enter(thisLock); 
      try      
      {
           if (money <= 0)
           {
                 Console.WriteLine("잔액이 모자랍니다.");
           }
           else
           {
                 money -= 1000;
           }
       }
       finally
       {
            Monitor.Exit(thisLock);
       }
}
```

위 두가지 방식은 같은 방법입니다. lock 키워드는  Monitor 클래스의 Enter() 와 Exit() 메소드를 바탕으로 구현되어 있습니다.

그럼에도 불구하고 Monitor클래스 방식을 적는 이유는 Monitor.Wait() 메소드와 Monitor.Pulse() 메소드로 더욱 섬세하게 멀티 쓰레드간의 동기화를 가능하게 해줄 수 있습니다.

Wait() 와 Pulse() 메소드는 반드시 lock 블록 안에서 호출해야 합니다. (그렇지 않으면 CLR 이 SynchronizationLockException을 던집니다)
쓰레드가 WaitSleepJoin 상태가 되면, 동기화를 위해 갖고 있던 lock 을 놓고 Waiting Queue 에 입력되고, 다른 쓰레드가 lock을 얻어 작업을 수행하게 됩니다.

Wait() 와 Pulse() 메소드를 호출할 때 일어나는 일은 다음 그림과 같습니다.
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Csharp_Language/11-4.png)

Thread.Sleep() 메소드도 쓰레드를 WaitSleepJoin State 가 될 수 있지만, Monitor.Pulse() 메소드에 의해 깨어날 수 없습니다. 다시 Running State 가 되려면 매개 변수로 입력된 시간이 경과되거나 Interrupt() 메소드 호출에 의해 깨어날 수 있습니다.

반면에 Monitor.Wait() 메소드는 Monitor.Pulse() 메소드가 호출되면 바로 깨어날 수 있습니다. 따라서 멀티 쓰레드 프로그램의 성능 향상을 위해서 Monitor.Wait() 와 Monitor.Pulse() 를 사용합니다.

사용방법은 다음과 같습니다.
1. 클래스 안에 동기화 객체 필드를 선언합니다.
2. 쓰레드를 WaitSleepJoin State로 바꿔 블록시킬 조건 (Wait()를 호출할 조건) 을 결정할 필드를 선언합니다.
3. 쓰레드를 블록시키고 싶은 곳에서는 lock 블록안에서 2번 과정에서 선언한 필드를 검사하여 Monitor.Wait()를 호출합니다.
4. 3번과정에서 선언한 코드는 lockedCount가 true면 해당 쓰레드를 블록시킵니다. 블록된 쓰레드가 깨어나면 lockedCount를 true로 변경합니다. 다른 쓰레드가 이 코드에 접근하면 3번 과정에서 선언했던 블로킹 코드에 걸려 같은 코드를 실행할 수 없습니다.
작업을 마치면 lockedCount의 값을 다시 false로 바꾼 뒤 Monitor.Pulse()를 호출합니다. 그럼 Waiting Queue에 대기하고 있던 다른 쓰레드가 깨어나서 false로 바뀐 lockedCount를 보고 작업을 수행합니다.

Wait()와 Pulse()를 사용한 예제를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Threading;
 
namespace CsharpStudy
{
    class Program
    {
        class Account
        {
            public int money = 1000;
             
            private readonly object thisLock = new object();
            private bool lockedCount= false; 
            // 다른 쓰레드가 공유된 자원을 사용하고 있는지 판별하기 위해 사용됨
 
            public void withdraw()
            {
                lock (thisLock)
                {
                    while (lockedCount == true) 
                    // 다른 쓰레드에 의해 true로 바뀌어있으면 현재 쓰레드를 블록시킵니다.
                        Monitor.Wait(thisLock); 
                        // 다른 쓰레드가 Pulse()를 호출해 줄때 까지는 WaitSleepJoin State 에 남습니다.
 
                    lockedCount = true;
 
                    if (money <= 0)
                    {
                        Console.WriteLine("잔액이 모자랍니다.");
                    }
                    else
                    {
                        money -= 1000;
                    }
 
                    lockedCount = false; // 다른 쓰레드를 꺠웁니다.
                    // 깨어난 쓰레드들은 while의 조건검사를 통해 
 					// Wait()를 호출할지 코드를 실행할지 결정합니다.
                    Monitor.Pulse(thisLock);
                }
            }
        }
 
        static void Main(string[] args)
        {
            Account account = new Account();
            Thread ATM = new Thread(new ThreadStart(account.withdraw));
            Thread Phone = new Thread(new ThreadStart(account.withdraw));
            Thread Internet = new Thread(new ThreadStart(account.withdraw));
 
            Console.WriteLine("ATM");
            ATM.Start();
            Console.WriteLine("Phone");
            Phone.Start();
            Console.WriteLine("Internet");
            Internet.Start();
        }
    }
}
```
### 11.4 Task (테스크)

CPU가 발전하면서 클럭을 높이는 방향에는 한계에 다다르자, 하나의 CPU안에 여러개의 코어를 집적하는 방향으로 제품을 향상시키기 시작했습니다.

이러한 하드웨어의 변화에 맞춰 소프트웨어도 변화를 최대로 활용할 수 있는 방법이 등장하고 있습니다.

.NET Framework 에는 System.Threading.Tasks 에는 병행성 코드나 비동기 코드의 실행을 돕는 클래스들이 들어 있습니다. 
(Task 또한 내부적으로 Thread로 구현됩니다)

Task 클래스를 이용하여 비동기(Asynchronous) 코드를 작성할 수 있습니다.
Task<TResult> 클래스는 코드의 비동기 실행 결과를 얻을 수 있습니다.
Task 클래스는 비동기로 수행할 코드를 Action 델리게이트로 주는 반면 Task<TResult> 는 Func 델리게이트로 줍니다.
즉 Task<TResult> 비동기 작업이 끝나면 Task<>.Result  프로퍼티에 값을 반환하게 됩니다.

 
Task 예제를 보겠습니다.
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
 
namespace CsharpStudy
{
    class Program
    {
        static void ActionMethod()
        {
            Thread.Sleep(1000);
            Console.WriteLine("ActionMethod Call");
        }
 
        static int FuncMethod(object a)
        {
            Thread.Sleep(500);
            Console.WriteLine("FuncMethod Call");
            return (int)a+5;
        }
 
        static void Main(string[] args)
        {
            Task task = new Task(ActionMethod);
            task.Start();                     // task는 비동기 호출로 1초후 완료된다.
            Console.WriteLine("Main Logic");  //Main Logic 문구가 바로 출력된다.
 
            Task int task2 = new Task int (FuncMethod, (object)10);
            // 매개변수와 반환값을 가진 메소드 사용방법
            task2.Start();
            task2.Wait(); // task2가 메소드가 완료될때 까지 대기
            Console.WriteLine("{0}", task2.Result); // 반환값 출력
 
            Console.WriteLine("Main Logic2");
 
            task.Wait(); //task의 메소드가 완료될때 까지 대기

            // Main Logic
            // FuncMethod Call
            // 15
            // Main Logic2
            // ActionMethod Call
        }
    }
}
```
결과를 보면 아시겠지만 실행해보면 Task 클래스에 의해 비동기 호출이 이루어짐을 알 수 있습니다.


추가적으로 예제를 작성하면서 알게 된건데,
위와 같은 코드에서 Main의 Sleep() 가 없을 경우 TaskMethod()에서 Sleep() 다음 코드가 출력되지 않습니다.
즉, Main 함수가 종료되면서 비동기 호출했던 TaskMethod 도 미처 다 실행하지 못하고 종료됩니다.
Thread를 만들어 이용할 경우에는 정상적으로 쓰레드가 다 종료되어야 프로그램이 종료되었지만 말이에요.
메소드를 비동기 호출할 때 끝까지 실행하기를 원한다면 Wait() 메소드를 이용하면 됩니다.
여기서 알 수 있는 것은 프로세스가 생성했던 쓰레드가 다 종료된 후에야 프로세스가 정상종료 되지만, Task는 프로세스가 종료되면서 강제종료되는 것 같습니다.

### 11.5 Parallel

Parallel 클래스는 좀더 쉽게 병렬처리를 하고 싶은 메소드를 처리할 수 있게 도와줍니다.
Parallel.For() 메소드는 주어진 델리게이트에 대하여 병렬로 호출합니다. 몇개의 쓰레드를 사용할 지는 내부적으로 판단하여 알아서 최적화하여 결정합니다.

Parallel 예제를 보겠습니다.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
using System.Threading;
 
namespace CsharpStudy
{
    class Program
    {
        static void ActionMethod(int num)
        {
            Thread.Sleep(1000);
            Console.WriteLine("ActionMethod Call {0}", num);
        }
 
        static void Main(string[] args)
        {
            Parallel.For(0, 100, ActionMethod); // 50 25 1 75 0 26 ....
        }
    }
}
```
결과를 보면 아시겠지만, 함수를 100번 호출하면서 병렬처리를 하기 때문에 순서가 뒤죽박죽이 되었고,
직접 실행해보면 아시겠지만, 10번 호출할때, 100번호출할때 매개변수값을 바꿔보면 처리방식이 조금씩 달라짐이 보입니다.
그리고 함수호출 한번당 1초정도 소요되게 코드를 짰지만, 병렬처리를 하면서 훨씬 빠르게 해당 프로그램이 종료됨을 보실 수 있습니다.

## 12. Garbage Colletion(가비지 컬렉션)

C 또는 C++ 언어로 프로그래밍을 하다보면 자주 사용하는 힙영역에 대한 메모리 해제때문에 머리 아픈 경우가 많았습니다.

하지만 C#에서는 가비지 컬렉터(Garbage Collector) 덕분에 아주 편하게 프로그래밍을 할 수 있게 됐습니다.

물론 C/C++ 프로그래밍에서 정확하고 안정적으로 코드를 짤 수 있다면 메모리를 효율적으로 사용할 때만 사용하고 버리고 싶을 때는 제거할 수 있겠지만, 사람인 이상 실수를 할 수 밖에 없습니다. 더군다나 프로그램이 커질수록 혼자만 코딩을 하는게 아니기 때문에 어쩔 수 없는 문제입니다. 또, C/C++ 기반의 프로그램을 실행하는 C-runtime 은 힙에 객체를 할당하기 위해 비싼 비용을 치르는 문제(메모리를 할당하기 위해 순차적으로 탐색하면서 객체를 담을만한 메모리 블록을 찾고, 메모리를 쪼개고, 메모리 블록의 리스트를 재조정하는; 탐색,분할,재조정의 오버헤드)를 가지고 있습니다.

C#에서는 가비지컬렉터가 사용하지 않는 객체를 알아서 판단하여 메모리를 회수합니다. 하지만, 가비지 컬렉터도 소프트웨어이기 때문에 CPU와 메모리를 사용합니다. 따라서 가바지 컬럭테가 최소한으로 자원을 사용하게 하는 것도 프로그램의 성능을 높이는 방법입니다. 

그래서 가비지 컬렉션의 메커니즘을 이해하고, 이를 바탕으로 어떻게 코딩지침을 세울 것인가를 정리하고자 합니다.

**가비지 컬렉션 메커니즘**

C#으로 작성한 프로그램을 실행하면 CLR은 프로그램을 위한 일정 크기의 메모리를 확보합니다. C-runtime 처럼 메모리를 쪼개는 일을 하지 않고 그냥 일정 메모리 공간을 확보해서 하나의 관리되는 힙(Managed Heap)을 마련합니다.

객체를 할당하게 되면 메모리에 순서대로 할당하게 됩니다. (CLR은 객체가 위치할 메모리를 할당하기 위해 공간을 쪼개만든 리스트를 탐색하는 시간도 소요하지 않고, 공간을 나눈 뒤에 리스트를 재조정하는 작업도 하지 않습니다)

참조 형식의 객체가 할당될 때는 스택 영역에는 힙의 메모리 주소를, 힙 영역에 실제 값이 할당된다고 했습니다.
그럼 객체가 할당된 코드블록이 끝나면 스택 영역의 메모리가 회수되고, 힙 영역에 값이 쓰레기가 됩니다.
여기서 회수된 스택의 객체를 루트(Root) 라고 부릅니다.
.NET 응용 프로그램이 실행되면 JIT 컴파일러가 이 루트들을 목록으로 만들고 CLR은 이 루트 목록을 관리하며 상태를 갱신하게 됩니다.

방법은 다음과 같습니다.

가비지 컬렉터는 힙영역의 임계치에 다다르게 되면
1. 모든 객체가 쓰레기라고 가정합니다.( 루트 목록 내의 어떤 루트도 메모리를 가리키지 않는다고 가정)
2. 루트 목록을 순회하면서 참조하고 있는 힙 객체와의 관계 여부를 조사합니다. 즉 어떤 루트와도 관계가 없는 힙의 객체들
   은 쓰레기로 간주됩니다.
3. 쓰레기가 차지하고 있던 메모리가 회수되면, 인접 객체들을 이동시켜 차곡차곡 채워서 정리합니다.

CLR의 메모리도 구역을 나누어 메모리에서 빨리 해제될 객체와 오래 있을 것 같은 객체를 따로 담아 관리합니다.

구체적으로 CLR은 메모리를 0세대, 1세대, 2세대 3가지로 분리하고, 0세대는 빨리 사라질 객체, 2세대는 오래 남아있을 것 같은 객체들을 위치시킵니다.

그 방법은 다음과 같습니다
응용 프로그램을 실행하면 0세대부터 할당된 객체들이 차오르기 시작합니다.
1. 0세대 가비지 컬렉션 임계치에 도달하면 0세대에 대해 가비지 컬렉션을 수행합니다. 여기서 살아남은 객체는 1세대로 옮
   겨집니다. 
2. 1번과정을 계속 반복하다보면, 1세대 가비지 컬렉션이 임계치에 도달하게 되고, 1세대에 대해 가비지 컬렉션을 수행합니
    다. 여기서 살아남은 객체는 다시 2세대로 옮겨집니다.
3. 2번과정도 지속되다보면 2세대 가비지 컬렉션이 임계치에 도달합니다.
   2세대 가비지컬렉션이 임계치에 도달하면 0,1,2 세대 전체 가비지컬렉션 (Full Garbage Collection) 을 수행합니다. 

프로그램이 오래 살아남는 개체들을 마구 생성하면, 2세대 힙이 가득차게 될 것입니다.

2세대 힙이 가득차게 되면 CLR은 응용프로그램의 실행을 멈추고 전체 가비지 컬렉션을 수행하면서 메모리를 확보하려 하기 때문에 응용 프로그램이 차지하는 메모리가 많을 수록 프로그램이 정지하는 시간도 그만큼 늘어나게 됩니다.

**코딩지침**

가비지 컬렉션의 메커니즘을 바탕으로 효율적인 코드를 작성하기 위한 방법이 있습니다.

* 객체를 너무 많이 할당하지 마세요.
* 너무 큰 객체 할당을 피하세요.
* 너무 복잡한 참조 관계는 만들지 마세요.
* 루트를 너무 많이 만들지 마세요.
* 객체를 너무 많이 할당하지마세요.

객체 할당 코드를 작성할 때 꼭 필요한 객체인지 필요 이상으로 많은 객체를 생성하지 않는지 고려하라는 말입니다.

너무 큰 객체 할당을 피하세요.

CLR은 85KB 이상의 대형 객체를 할당하기 위한 대형 객체 힙 (Large Object Heap ; LOH) 을 따로 유지하고 있습니다.
대형 객체가 0세대에 할당하면 가비지 컬렉션을 보다 자주 수행하기 때문입니다.
대형 객체 힙은 객체의 크기를 계산한 뒤 여유공간이 있는지 힙을 탐색하여 할당합니다. 또한, 대형 객체 힙은 해제된 공간을 인접 객체가 채우는 것이 아니라 그대로 둡니다. 대형 객체를 복사하여 옮기는 비용이 너무 비싸기 때문입니다. 이로 인해 큰 공간 사이사이가 메모리를 낭비하게 됩니다. (C-runtime 방식의 문제점과 비슷합니다)

너무 복잡한 참조관계는 만들지 마세요.

참조 관계가 많은 객체는 가비지 컬렉션 후에 살아남아 있을 때가 문제입니다. 살아 남은 객체는 세대를 옮기기 위해 메모리 복사를 진행하는데, 참조 관계가 복잡할 경우 객체를 구성하고 있는 각 필드 객체간의 참조관계를 조사하여 메모리 주소를 전부 수정해야 되기 때문에 탐색과 수정의 오버헤드가 발생합니다. 또한 A객체가 2세대인데 A 객체안에 B객체를 이제막 생성하여 0세대로 되었다면, A의 인스턴스는 2세대에 있고 B 필드를 참조하는 메모리는 0세대에 위치하게 됩니다. 이때 0세대 가비지 컬렉션이 수행된다면 B필드가 수거될 수 있습니다. 하지만 CLR은 쓰기 장벽(Write barrier)이라는 장치를 통해서 B필드가 루트를 갖고 있는 것으로 간주하게 해서 수거 되지 못하게 합니다. 이 쓰기 장벽을 생성하는 데 오버헤드가 크다는 것이 문제가 됩니다.

루트를 너무 많이 만들지 마세요.

가비지 컬렉터는 루트 목록을 돌면서 쓰레기를 수거하기 때문에 적을 수록 성능에 유리합니다.







