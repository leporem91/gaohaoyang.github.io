---
layout: post
title:  "소프트웨어공학"
date:   2015-10-21 21:46:00
categories: 학교수업
tags: 학교수업
---

* content
{:toc}


소프트웨어 공학 수업에 대한 강의내용을 정리합니다.

## 1. Introduction

**What is Software?**

소프트웨어는 프로그램(소스코드) 뿐만 아니라, 그와 관련된 문서와 데이터를 모두 총칭하는 말이다.

**Why Software Project Fail?**

* Lack of SW mind - 소프트웨어의 개발 및 유지보수가 쉽고 빠르게 되는 줄 알고 있다.

* Lack of appropriate SE skills - 실력 자체가 부족하다.

* Insufficient software project management - 프로젝트 관리를 하지 않는다.



**Why is Software Development So Difficult?**

* Communications - 개발자와 클라이언트의 의사소통이 어렵다.

* Sequential nature of system

* Development - 사람이 직접 개발하기 때문이다. (Manufacturing이 아니다)

* Project characteristics - 프로젝트가 다양하다.

* Characteristics of personnel - 사람들의 성격이 다양하다.

* Management issues - 일정관리나 직원관리가 어렵다.


**Costs of Software Development**

* Analysis & Design (40%) - 요구사항을 제대로 이해하기 위해서 많은 시간을 투자하게 된다.

* Coding (20%) - 실제적인 코딩은 아주 적은 시간이 소요된다.

* Testing (40%) - 에러를 최대한 줄여 a/s 비용을 최소화한다.


**Development vs Maintenance**

* Maintenance (66%) - 유지보수 비용이 훨씬 많이 든다.

* Development (33%)



**Sources of Errors in Software Developments**

* Documentation & Others (35%) - 코드와 문서의 불일치 혹은 문서없음이 가장 많은 비중을 차지한다.

* Coding (30%)

* Logic design & Misunderstanding (20%)

* Functionality & Misunderstanding (15%)


**Programming Paradigm Evolution**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/1-1.jpg)

항상 생산성과 품질을 향상시키기 위해 발전하고 있다.

요즘 트렌드는 Service-Oriented Architecture, Saas(Software as a Service), Open Source Market, Offshore Outsourcing, Cloud computing 등이 있다.


**What is Software Enginnering**

The application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software ( IEEE, 1991) - 응용 프로그램 개발에 있어서 체계적이고, 규범화하고 수치화하여 접근하는 방법을 말한다.

What you do when you have two or more people working on a project ( NRC Canada 1997)


**소프트웨어 공학이 중요해진 이유**

소프트웨어 개발에 있어서 항상 시간과 노력 그리고 비용까지 전부 예측할 수 있어야 한다.

소프트웨어의 수요가 증가하고, 이제는 하드웨어 비용보다 소프트웨어 비용이 더 높아졌고, 중요해졌기 때문에 소프트웨어의 규모는 점점 커진다. 따라서 유지보수의 역할의 중요성이 커졌고, 소프트웨어 품질이 중요해졌다.

소프트웨어 공학의 최종목표는 소프트웨어 품질의 향상이다.

## 2. Software Qualities

**Software Development Process**

1. Feasibility Study - 기술적인 관점에서 실현가능성을 확인한다.
2. Requirements Analysis & Specification - 요구사항을 정의한다.
3. Design 
4. Coding & Unit Testing
5. Integration & System testing
6. Delivery & Maintenance


**Software Qualities - Definitions**

* The degree to which the attributes of software enable it to perform its intended end use. (DoD, 1985)
(사용자의 요구를 제대로 수행하고 attributes of software 즉, 문서나 데이터 등이 제대로 정립되었는가?)

* The totality of features and characteristics of a product or a service that bear on its ability to satisfy specified or implied needs. (ISO, 1986)
 (소프트웨어가 고객의 요구를 제대로 만족시킬수 있는 능력이다.)

* Fitness for needs ( Kitchenham, 1986)
 (고객의 요구에 적합한가?)



**Why software quality is different from other types of quality?**

* software has no physical existence - 물리적으로 존재하는 것이 아니기 때문이다.

* The lack of knowledge of client needs at the start - 요구에 대한 지식이 부족하다. (소프트웨어는 여러 분야에 활용된다.)

* The change of client needs over time. - 고객의 요구가 변경된다.

* The high expectation of customers. - 고객이 기대치가 높다.


**Qualities Classification**

* External and Internal Qualities, Product and Process Qualities

* External Quality - 사용자의 기준에서 (UI 나 시스템 성능 등)

* Internal Quality - 개발자 기준에서 ( 모듈화나 가독성 등)

* Product Quality - 소프트웨어 자체에서 Functionality, Usability, Efficiency, Reliability 등..

* Process Quality - 소프트웨어 개발 절차에서 Effectiveness of methods, tools, Use of standards, Managements 등..


**Representative Qualities**
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/2-1.PNG)

**Quality Requirements in Specific Apllication Areas**
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/2-2.PNG)

**소프트웨어 품질이 중요한 이유**

소프트웨어 공학이라고 하는 것은 결국 소프트웨어 품질을 향상시키기 위해서 존재한다.

제품의 품질을 높인다는 것은 고객의 요구를 완벽하게 이루어내고 품질을 높여 수익을 증대시키기 때문이다.

소프트웨어 품질을 측정하는 방법의 한 예는 Mecabe's cyclomatic complexity 를 들 수 있다.

control flow graph를 이용하여 소프트웨어 복잡도를 수치화 한다.

V(G) = E- N+ 2*P 로 표현할 수 있다. ( E: Edge, N: Node, P: connected compotents)


마지막으로 소프트웨어 품질은 요구사항에 얼마나 적합한가를 나타낸다.

## 3. Software Engineering Principles

Principles 은 method와 기술, 방법론과 툴의 기반(기본)이 되는 것이다.

소프트웨어 개발의 모든 부분에서 사용되는 것이다.

모듈화는 소프트웨어 설계에 있어서 cornerstone이다.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/3-1.PNG)

마지막으로 위의 Principles 은 소프트웨어의 모든 개발활동에 모두 쓰여지고 필수이므로, 중요하다고 할 수 있다.

## 4. Software Production Process

**What is Software Process Model?**

소프트웨어를 개발하는 과정은 이미 많이 사용되어지고 검증된 방법들로 개발하는 것이 좋다.

프로세스 모델의 목표는 당연히, 고객의 요구를 만족시키는 것이다.

여기서 고객의 요구는 구체적으로 품질 좋은 제품을 제 시간안에, 정해진 예산안에, 신뢰성있고, 효율적인 것을 말한다.

소프트웨어의 life-cycle은 다음과 같다.

Requirements -> Analysis -> Design -> Coding -> Testing -> Delivery -> Operations and Maintenance -> Retirement

**Why Process Model Important?**

장기적으로 보면 시간을 단축할 수 있고, 그만큼 비용도 줄어든다.

제품의 품질과 관련이 있다.

프로젝트를 투명하게 관리할 수 있다.



**Software Process Models**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/4-1.PNG)

**CMMI (Capability Maturity Model, Integration by CMU/SEI)**

미국에서 개발한 방법으로 소프트웨어의 품질을 평가하고 보증하는 기준안이다.

소프트웨어의 능력이 얼마나 성숙되었는가를 측정하는 것으로 5단계로 나뉘어진다.

Performed => Managed => Defined => Quantitatively Managed => Optimizing



**소프트웨어 프로세스 모델이 필요한 이유**

소프트웨어 개발 과정 자체를 투명하게 보여 줄 수 있어, 관리가 수월하다.

또한 프로젝트의 규모가 커질 수록 품질과 아주 밀접한 관계가 있기 때문에 필요하다.

마지막으로 소프트웨어 프로세스 모델(Process Model)은 무엇을 해야할 지를 정의하고, 방법론(Methodology)는 어떻게 해야 할지를 정의하는 것이다.

## 5. Project Management

**Project Management - Definition**

* Creation and maintenance of an internal environment in an enterprise where individuals, working together in groups, can perform efficiently and effectively toward the attainment of group goals.

(일할때 필요한 환경을 잘 만들고, 잘 유지하는 것이다. 그룹을 지어 함께 일하는 것이기 때문에 목표를 달성하기 위해서는 효과적인 방법이 필요하다.)


**Management Steps**

1. Planning
 - Understanding & documenting the goal.
   (문서와 목표를 정확하게 정의하고, 요구되는 자원과 예산등을 예측한다.)
 - Developing a schedule, budget and other resource req.s.
   (어떻게 예측할 것인지가 화두가 된다.)

2. Acquisition of resources
 - Space, computing resources, materials and human resources.

3. Execution
 - Putting the plan into a action.

4. Monitoring
 - Checking the progress of the project.
 - Taking necessary actions to handle deviation from the plan.


**Software Productivity**

소프트웨어의 생산성은 크게 두가지로 분류한다. (프로그램의 코드라인수 vs 프로그램의 기능 관점)

LOC (line of code)

  - DSI(delivered source instructions)로 주석과 코드를 함께 라인수로 책정하는 방법.
  - NCSS(non-commented source statement) 로 실행되는 코드의 라인수만 책정하는 방법.

코드의 라인수는 측정하기는 쉽지만 문제가 많아 잘 사용되지 않는다.

Function Points

 요구사항의 기능에 각각 점수를 부여하여 기능이 얼마나 많고 복잡한가를 나타내서 예산을 측정하는 방법이다.

 좀더 깊게 설명하면, 먼저 프로젝트의 분야를 정하고, 그 기능이 쉬운지, 어려운지를 판단하여 가중치를 부여한 후에, 모두 더한

 UFP (unadjusted FP) 를 구한다. 그 다음 14가지의 시스템 특성에 따라 가중치(VAF)를 다시 구하여 Total DI를 구한다.

 그런 후에 AFP(adjusted FP)= UFP X ( TDI * 0.01 + 0.65) 의 식으로 AFP를 구하면 된다.

이 외에도 소프트웨어의 생산성에 영향을 주는 것은 요구사항의 신뢰도, 타이밍 제약, 기한, 언어 경험, 개발자의 이직 등 다양한 점이 영향을 줄 수 있다.


**Techniques of Software Cost Estimation**

소프트웨어의 비용을 평가하는 기술들은 Expert judgement, Parkinson's Law, Top- down, Bottom-up 등 다양하게 존재한다.

대표적으로 COCOMO가 있다.

COCOMO는 LOC를 기반으로 비용을 측정한다.

프로젝트의 개발이 어려운지 정도에 따라 3가지 정도로 분류한 후에 계산식이 존재한다.

예를 들어, 소규모 프로젝트일 경우에는 PM (person- Month) = 2.4(KDSI)^1.05 을 구한 후 Effort Multiplier를 여러가지 항목을 검토하여 정한다. 그런후에 PMdev= PM*Effort multiplier 를 구한 후, TDEV = 2.5*(PMdev)^0.38 로 구할 수 있다.

즉 COCOMO는 LOC를 기반으로 하되 여태까지 프로젝트들의 경험을 토대로 만들어진 식으로 구하게 된다.

FP가 더 각광을 받으면서 LOC뿐만 아니라 FP을 결합한 측정방법 COCOMO2으로 발전한다.

**Project Control**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/5-1.PNG)

**Team Organization**

경영은 조직을 구성하는데 개인의 역할을 잘 정의하고 할당하여 프로젝트의 목표를 이루어내는 것이다.

 * Centralization-conrol team
 장점: 소규모에 적합. 일이 정확하게 이해됐고, 관리가 정확할때 적합. 매니저의 능력
 단점: 의사소통이 어렵다.

 * Decentralized-control team
 장점: 긴 프로젝트에 적합. 일이 이해가 어렵고 복잡할때, 팀원간 의사소통이 활발하다.
 단점: 사람이 많으면 어렵다.

큰 규모는 보통 위 두가지를 믹스해서 사용한다.


Contents of SPMP

SPMP(Software Project Managenemnt Plan)의 구성은 다음과 같다.

1. Introduction - Purpose of this document, Project overview, Related docuemnts / terms ...
2. Development Plan - Resource, Schedule
3. Organization - Team structure, Role
4. Technical Management - Configuration management, Technology management
5. Quiality control - Review Method, Review  periodic...
6. Development Environment - Required software and spec, Hardware spec, Space and security ...
7. Deliverables - define the documents , date ...
8. Others - Considerable issues ..
9. References

규모가 커질 경우 목차의 일부분이 따로 문서가 작성된다.

4번은 SCMP (Software Configuration Management Plan)

5번은 SQAP (Software Quality Assurance Plan)

## 6. Requirement Analysis & Specification

**Feasibility Study**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-1.PNG)


**Information (Requirements) Gathering**

- Interviewing
- Documents
- Joint Application development
- Questionnaires
- Observation


Interview Process
 * Before interview 
   인터뷰 계획수립 - 토픽을 정함, 질문 정리, 팀원 구성, 고객 비즈니스 이해, 고객 조직 이해
 * During interview
 최대한 고객의 의견을 끌어낼 수 있도록 질문은 짧게 진행한다. 
 * After interview
 노트 기록 및 요약
 

**Requirements Description**

Requirements

- a statement of what the system must do or what characteristic it must have. - 시스템이 정확히 무엇을 하는지 명시
- can be changed over time as moves from analysis to design
- can be either functional requirements or nonfuncitional requirements
- Incorrect specification is major reason for project's failure. - 요구사항 명세가 정확하도록 해야 한다.
- Late discovery of problems is costly. - 나중에 발견되는 문제일수록 큰 비용이 발생한다.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-2.PNG)

**Specification Qualities**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-3.PNG)


**요구사항 명세서가 중요한 이유**

요구사항 또는 명세서 자체가 잘못된 경우 다음 단계에 진행되는 과정에서 문제가 발생하고, 그 문제만큼 비용이 크게 증가한다.

따라서 정확히 파악한 요구사항이 정확하게 명세서로 작성될 경우 프로젝트의 변경이 적고 시간소모도 적다.

**Methods for Requirements Analysis & Specification**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-4.PNG)

**Structured Analysis**

여러가지 분석법 중 구조적 분석방법을 정리합니다.

※ Structured Analysis : Overview

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-5.PNG)

※ Structured Analysis : Overall Process

1. **Brain storming** on the problem and establish the problem statement that describes the key requirements.
2. Identify the events accepted or generated by the system. (And record the results on the **Event Table**)
3. Draw a **System Context Diagram**
4. Decompose diagrams to capture the details as required to describe what the system should do.
 (And record the results on the corresponding **Data Flow Diagram**)
 
5. Describe the internal behavior of each bubble at the **Process Specification**.
6. Define input/output specification of each bubble at the **Data Dictionary**.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-6.PNG)

이 외에 좀더 복잡한 로직을 갖고 있다면 State Transition Diagram(STD)를 추가적으로 작성한다.

Contents of SRS
1. Introduction
 - Purpose of this document
 - Project overview
 - Related documents, terms, abbreviations

2. Requirements
 - Data flow diagram
 - Data dictionary
 - Process spec (Mini-spec)
 - Other functional Characteristics

3. Other Requirements or Constraints
 - Performance requirements
 - Hardware requirements
 - Exception handling
 - User interface constraints
 - Other constraints

4. Acceptance Criteria
 - Functionality test criteria
 - Performance test criteria

5. Others
 - Considerable issues

6. Traceability Analysis
 - Traceability matrix

7. References and Appendix

**소프트웨어 개발에 있어서 객체지향 분석 또는 구조적 분석 등 methodology를 선택하는 기준은 무엇인가?**

회사의 방침 또는 프로그래머의 스킬, 구현 언어, 개발 분야 등에 따라서 적합한 방법론을 선택한다.

## 7. Software Design

- A process through which requirements are translated into a representation of software.

- Software design methodology lacks the depth, flexibility and quantitative nature in comparison to classical engineering fields.

요구사항을 소프트웨어로 개발하기 위하여 개발자의 관점에서 작성한다.


**Characteristics of Good Design**

- A design should exhibit a hierarchical structure.
  (계층구조로 보기 쉽게)
- A design should be modular.
  (모듈화)
- A design should contain distinct and separable representation of data and procedure.
 (데이터로 나타낼 부분과 Procesure로 나타내야할 부분을 분리한다.)
- A design should lead to modules that exhibit independent functional characteristics.
 (독립적인 기능을 모듈화한다)
- A design should lead to interfaces that reduce the complexity of connections between modules and with the external environment.
 (외부환경과 결합되기 쉽게 복잡하지 않은 인터페이스로 설계한다.)


**Modularity in details**

※ Coupling

Degree of interdependence between two modules.

두 모듈 사이의 관계가 형성될때 그 결합강도.


Low coupled system

- Prevent ripple effect - 파급효과 억제
- Enhance understandability - 이해력 향상

Objective: Minimize coupling

- Make modules as independent as possible. - 가능한 독립적인 모듈로 만든다.
- Indicates a well-partitioned system.

How to achieve low coupling

- Eliminating unnecessary relationships - 불필요한 관계를 제거한다.
- Reducing the number of necessary relationships - 필요한 관계도 최소화한다.


※ Scale of Coupling

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/7-1.PNG)

※ Cohesion

The measure of the strength of functional relatedness of elements within a module

(하나의 모듈안에서 각 요소가 공통의 목적을 달성하기 위한 응집도)


Objective: **Maximize Cohesion**

- Make modules whose elements are strongly and genuinely related to one another


Relationship between Coupling and Cohesion

- 2 ways to evaluate the partitioning of a system
- The cohesion of a module often determines how tightly it will be coupled to other modules in a system, and vice versa.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/7-2.PNG)

**좋은 소프트웨어 설계란?**

모듈화 원칙을 지키고 유지보수가 쉽게 할 수 있도록 설계하는 것이다.

모듈화 원칙은 Low Coupling + High Cohesion 이다.


※ Design in Technical aspects

* Data design
 - transformation of the information domain model created during analysis into    the data structures.(데이터베이스 설계)

* Architectural design
 - definition of the relationship among major structural components of the software. (전체 시스템을 이루는 서브시스템, 모듈 관계파악)

* Procedural design
 - transformation of structural components into a  procedural description of the software.

* (User) Interface design
  - establishment of the layout and interaction mechanisms for human-machine interaction. (메뉴나 입력양식 설계)
 
** Structured Design : Architectural Design **

A process through which requirements are translated into a representation of software.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/7-4.PNG)


**Architectural Design : Task Model**

Task Model :

represents how tasks collaborate with each other to realize the Flow Diagrams

To design task model is the most important work of embedded system development 

- Because it has significant impact system’s performance, reliability, required resource, and so on 



**We develop task models through the following steps**

- Integrating data flow diagrams into a whole DFD.
- Identifying candidate tasks  
   Each control process can form a 'Control Task'
   
   Process can form a task when it is either Periodic or Asynchronous 

- Allocating remaining processes 
- Merging tasks  


**※ Tips for Allocating Remaining Processes**

Allocating and merging heuristics (응집력과의 관계를 생각한다)

- Control Cohesion 
  Control process may be grouped with the processes it uses into a task 
  For example, triggered synchronous function 

- Sequential Cohesion  
  Certain processes perform operations that must be carried out in a sequential order 

- Temporal Cohesion 
  Certain processes may perform operations that are activated by the same event 

- Functional Cohesion 
  Functional cohesion occurs when there are one or more functions that are closely related 


When a set of tasks are working in a mutually exclusive manner(independent), they can be grouped into a single task


**Structured Design : Detailed Design**


※ Overview of Structured Design

- Goal of Structured Design is to build a model to describe how the **system work** (시스템이 어떻게 동작하는지)

- Can convert Flow Diagrams into a **structure chart** at task level.

- After architectural design, we perform Structured Design for each task 

 - For Flow Diagrams in each task, we convert it into structure chart using modular design strategies
 - Then, we refine the result to describe the enough details of tasks


Structure Chart:
 Modules, Invocations, Couples, Control Abstraction 등의 정해진 Symbols을 이용하여  어떻게  컨트롤하는지를 그린 그림.

 Module Specification :
 모듈의 세부적인 내용을 슈도코드로 작성한 것.
 
 
 **Refining Structure Chart**

* Make each module cohesively  - High Cohesion

* Keep the coupling between modules loosely - Low Coupling

* Factoring - 공통된 속성을 뽑아서 하나의 클래스로 만든다.

* Reduce Fan-Out - 두 개의 모듈을 최대한 합쳐라 ( 다른 모듈을 호출하지 않게)

* Delete Dummy Module

* Localization for Periodic Process - 데이터를 필요로할때 계속 요청하지 않고 local화하여 값이 변경되었을 때만 알린다.



Contents of  SDD

1. Introduction 
 - Purpose of this document 
 - Project overview 
 - Related documents, terms, abbreviations 

2. Architectural Design 
 - Architecture model 
 - Model description  
 
3. Module Design  
 - For each module  
 - Design model 
 - Module specification 
    
4. Interface Design 
 - Software interface 
 - Communication interface  

5. Data Design 
 - Data structure design 
 
6. Implementation Design 
 - Required SW technologies  
 - HW technologies  

7. Others
 - Considerable issues 

8. Traceability Analysis  
 - Traceability matrix  

9. References and Appendix


**What is the difference betwwen DFD and Structure chart?**

 DFD - 데이터의 흐름만 구성 ( 처리관점 )

 Structure chart - 실행 개념 ( 컨트롤 관점 )





