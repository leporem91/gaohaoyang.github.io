---
layout: post
title:  "소프트웨어공학"
date:   2015-10-21 21:46:00
categories: 학교수업
tags: 학교수업
---

* content
{:toc}


소프트웨어 공학 수업에 대한 강의내용을 정리합니다.

## 1. Introduction

**What is Software?**

소프트웨어는 프로그램(소스코드) 뿐만 아니라, 그와 관련된 문서와 데이터를 모두 총칭하는 말이다.

**Why Software Project Fail?**

Lack of SW mind - 소프트웨어의 개발 및 유지보수가 쉽고 빠르게 되는 줄 알고 있다.

Lack of appropriate SE skills - 실력 자체가 부족하다.

Insufficient software project management - 프로젝트 관리를 하지 않는다.



**Why is Software Development So Difficult?**

Communications - 개발자와 클라이언트의 의사소통이 어렵다.

Sequential nature of system

Development - 사람이 직접 개발하기 때문이다. (Manufacturing이 아니다)

Project characteristics - 프로젝트가 다양하다.

Characteristics of personnel - 사람들의 성격이 다양하다.

Management issues - 일정관리나 직원관리가 어렵다.



**Costs of Software Development**

Analysis & Design (40%) - 요구사항을 제대로 이해하기 위해서 많은 시간을 투자하게 된다.

Coding (20%) - 실제적인 코딩은 아주 적은 시간이 소요된다.

Testing (40%) - 에러를 최대한 줄여 a/s 비용을 최소화한다.



**Development vs Maintenance**

Maintenance (66%) - 유지보수 비용이 훨씬 많이 든다.

Development (33%)



**Sources of Errors in Software Developments**

Documentation & Others (35%) - 코드와 문서의 불일치 혹은 문서없음이 가장 많은 비중을 차지한다.

Coding (30%)

Logic design & Misunderstanding (20%)

Functionality & Misunderstanding (15%)


**Programming Paradigm Evolution**
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/1-1.jpg)

항상 생산성과 품질을 향상시키기 위해 발전하고 있다.

요즘 트렌드는 Service-Oriented Architecture, Saas(Software as a Service), Open Source Market, Offshore Outsourcing, Cloud computing 등이 있다.


**What is Software Enginnering**

The application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software ( IEEE, 1991) - 응용 프로그램 개발에 있어서 체계적이고, 규범화하고 수치화하여 접근하는 방법을 말한다.

What you do when you have two or more people working on a project ( NRC Canada 1997)


**소프트웨어 공학이 중요해진 이유**

소프트웨어 개발에 있어서 항상 시간과 노력 그리고 비용까지 전부 예측할 수 있어야 한다.

소프트웨어의 수요가 증가하고, 이제는 하드웨어 비용보다 소프트웨어 비용이 더 높아졌고, 중요해졌기 때문에 소프트웨어의 규모는 점점 커진다. 따라서 유지보수의 역할의 중요성이 커졌고, 소프트웨어 품질이 중요해졌다.

소프트웨어 공학의 최종목표는 소프트웨어 품질의 향상이다.

## 2. Software Qualities

**Software Development Process**

1. Feasibility Study - 기술적인 관점에서 실현가능성을 확인한다.
2. Requirements Analysis & Specification - 요구사항을 정의한다.
3. Design 
4. Coding & Unit Testing
5. Integration & System testing
6. Delivery & Maintenance


**Software Qualities - Definitions**

The degree to which the attributes of software enable it to perform its intended end use. (DoD, 1985)

- 사용자의 요구를 제대로 수행하고 attributes of software 즉, 문서나 데이터 등이 제대로 정립되었는가?

The totality of features and characteristics of a product or a service that bear on its ability to satisfy specified or implied needs. (ISO, 1986)

- 소프트웨어가 고객의 요구를 제대로 만족시킬수 있는 능력이다.

Fitness for needs ( Kitchenham, 1986)

- 고객의 요구에 적합한가?



**Why software quality is different from other types of quality?**

software has no physical existence - 물리적으로 존재하는 것이 아니기 때문이다.

The lack of knowledge of client needs at the start - 요구에 대한 지식이 부족하다. (소프트웨어는 여러 분야에 활용된다.)

The change of client needs over time. - 고객의 요구가 변경된다.

The high expectation of customers. - 고객이 기대치가 높다.



**Qualities Classification**

External and Internal Qualities, Product and Process Qualities

External Quality - 사용자의 기준에서 (UI 나 시스템 성능 등)

Internal Quality - 개발자 기준에서 ( 모듈화나 가독성 등)

Product Quality - 소프트웨어 자체에서 Functionality, Usability, Efficiency, Reliability 등..

Process Quality - 소프트웨어 개발 절차에서 Effectiveness of methods, tools, Use of standards, Managements 등..



**Representative Qualities**
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/2-1.PNG)

**Quality Requirements in Specific Apllication Areas**
![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/2-2.PNG)

**소프트웨어 품질이 중요한 이유**

소프트웨어 공학이라고 하는 것은 결국 소프트웨어 품질을 향상시키기 위해서 존재한다.

제품의 품질을 높인다는 것은 고객의 요구를 완벽하게 이루어내고 품질을 높여 수익을 증대시키기 때문이다.

소프트웨어 품질을 측정하는 방법의 한 예는 Mecabe's cyclomatic complexity 를 들 수 있다.

control flow graph를 이용하여 소프트웨어 복잡도를 수치화 한다.

V(G) = E- N+ 2*P 로 표현할 수 있다. ( E: Edge, N: Node, P: connected compotents)


마지막으로 소프트웨어 품질은 요구사항에 얼마나 적합한가를 나타낸다.

## 3. Software Engineering Principles

Principles 은 method와 기술, 방법론과 툴의 기반(기본)이 되는 것이다.

소프트웨어 개발의 모든 부분에서 사용되는 것이다.

모듈화는 소프트웨어 설계에 있어서 cornerstone이다.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/3-1.PNG)

마지막으로 위의 Principles 은 소프트웨어의 모든 개발활동에 모두 쓰여지고 필수이므로, 중요하다고 할 수 있다.

## 4. Software Production Process

**What is Software Process Model?**

소프트웨어를 개발하는 과정은 이미 많이 사용되어지고 검증된 방법들로 개발하는 것이 좋다.

프로세스 모델의 목표는 당연히, 고객의 요구를 만족시키는 것이다.

여기서 고객의 요구는 구체적으로 품질 좋은 제품을 제 시간안에, 정해진 예산안에, 신뢰성있고, 효율적인 것을 말한다.

소프트웨어의 life-cycle은 다음과 같다.

Requirements -> Analysis -> Design -> Coding -> Testing -> Delivery -> Operations and Maintenance -> Retirement

**Why Process Model Important?**

장기적으로 보면 시간을 단축할 수 있고, 그만큼 비용도 줄어든다.

제품의 품질과 관련이 있다.

프로젝트를 투명하게 관리할 수 있다.



**Software Process Models**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/4-1.PNG)

**CMMI (Capability Maturity Model, Integration by CMU/SEI)**

미국에서 개발한 방법으로 소프트웨어의 품질을 평가하고 보증하는 기준안이다.

소프트웨어의 능력이 얼마나 성숙되었는가를 측정하는 것으로 5단계로 나뉘어진다.

Performed => Managed => Defined => Quantitatively Managed => Optimizing



**소프트웨어 프로세스 모델이 필요한 이유**

소프트웨어 개발 과정 자체를 투명하게 보여 줄 수 있어, 관리가 수월하다.

또한 프로젝트의 규모가 커질 수록 품질과 아주 밀접한 관계가 있기 때문에 필요하다.

마지막으로 소프트웨어 프로세스 모델(Process Model)은 무엇을 해야할 지를 정의하고, 방법론(Methodology)는 어떻게 해야 할지를 정의하는 것이다.

## 5. Project Management

**Project Management - Definition**

Creation and maintenance of an internal environment in an enterprise where individuals, working together in groups, can perform efficiently and effectively toward the attainment of group goals.

- 일할때 필요한 환경을 잘 만들고, 잘 유지하는 것이다. 그룹을 지어 함께 일하는 것이기 때문에 목표를 달성하기 위해서는 효과적인 방법이 필요하다.


**Management Steps**

1. Planning 

 Understanding & documenting the goal.

 Developing a schedule, budget and other resource req.s.

 문서와 목표를 정확하게 정의하고, 요구되는 자원과 예산등을 예측한다.

 ( 어떻게 예측할 것인지가 화두가 된다.)

2. Acquisition of resources

 Space, computing resources, materials and human resources.

3. Execution

 Putting the plan into a action.

4. Monitoring

 Checking the progress of the project.

 Taking necessary actions to handle deviation from the plan.


**Software Productivity**

소프트웨어의 생산성은 크게 두가지로 분류한다. (프로그램의 코드라인수 vs 프로그램의 기능 관점)

LOC (line of code)

  - DSI(delivered source instructions)로 주석과 코드를 함께 라인수로 책정하는 방법.
  - NCSS(non-commented source statement) 로 실행되는 코드의 라인수만 책정하는 방법.

코드의 라인수는 측정하기는 쉽지만 문제가 많아 잘 사용되지 않는다.

Function Points

 요구사항의 기능에 각각 점수를 부여하여 기능이 얼마나 많고 복잡한가를 나타내서 예산을 측정하는 방법이다.

 좀더 깊게 설명하면, 먼저 프로젝트의 분야를 정하고, 그 기능이 쉬운지, 어려운지를 판단하여 가중치를 부여한 후에, 모두 더한

 UFP (unadjusted FP) 를 구한다. 그 다음 14가지의 시스템 특성에 따라 가중치(VAF)를 다시 구하여 Total DI를 구한다.

 그런 후에 AFP(adjusted FP)= UFP X ( TDI * 0.01 + 0.65) 의 식으로 AFP를 구하면 된다.

이 외에도 소프트웨어의 생산성에 영향을 주는 것은 요구사항의 신뢰도, 타이밍 제약, 기한, 언어 경험, 개발자의 이직 등 다양한 점이 영향을 줄 수 있다.


**Techniques of Software Cost Estimation**

소프트웨어의 비용을 평가하는 기술들은 Expert judgement, Parkinson's Law, Top- down, Bottom-up 등 다양하게 존재한다.

대표적으로 COCOMO가 있다.

COCOMO는 LOC를 기반으로 비용을 측정한다.

프로젝트의 개발이 어려운지 정도에 따라 3가지 정도로 분류한 후에 계산식이 존재한다.

예를 들어, 소규모 프로젝트일 경우에는 PM (person- Month) = 2.4(KDSI)^1.05 을 구한 후 Effort Multiplier를 여러가지 항목을 검토하여 정한다. 그런후에 PMdev= PM*Effort multiplier 를 구한 후, TDEV = 2.5*(PMdev)^0.38 로 구할 수 있다.

즉 COCOMO는 LOC를 기반으로 하되 여태까지 프로젝트들의 경험을 토대로 만들어진 식으로 구하게 된다.

FP가 더 각광을 받으면서 LOC뿐만 아니라 FP을 결합한 측정방법 COCOMO2으로 발전한다.

**Project Control**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/5-1.PNG)

**Team Organization**

경영은 조직을 구성하는데 개인의 역할을 잘 정의하고 할당하여 프로젝트의 목표를 이루어내는 것이다.

 * Centralization-conrol team
 장점: 소규모에 적합. 일이 정확하게 이해됐고, 관리가 정확할때 적합. 매니저의 능력
 단점: 의사소통이 어렵다.

 * Decentralized-control team
 장점: 긴 프로젝트에 적합. 일이 이해가 어렵고 복잡할때, 팀원간 의사소통이 활발하다.
 단점: 사람이 많으면 어렵다.

큰 규모는 보통 위 두가지를 믹스해서 사용한다.


Contents of SPMP

SPMP(Software Project Managenemnt Plan)의 구성은 다음과 같다.

1. Introduction - Purpose of this document, Project overview, Related docuemnts / terms ...
2. Development Plan - Resource, Schedule
3. Organization - Team structure, Role
4. Technical Management - Configuration management, Technology management
5. Quiality control - Review Method, Review  periodic...
6. Development Environment - Required software and spec, Hardware spec, Space and security ...
7. Deliverables - define the documents , date ...
8. Others - Considerable issues ..
9. References

규모가 커질 경우 목차의 일부분이 따로 문서가 작성된다.

4번은 SCMP (Software Configuration Management Plan)

5번은 SQAP (Software Quality Assurance Plan)

## 6. Requirement Analysis & Specification

**Feasibility Study**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-1.PNG)


**Information (Requirements) Gathering**

- Interviewing
- Documents
- Joint Application development
- Questionnaires
- Observation


Interview Process
 * Before interview 
   인터뷰 계획수립 - 토픽을 정함, 질문 정리, 팀원 구성, 고객 비즈니스 이해, 고객 조직 이해
 * During interview
 최대한 고객의 의견을 끌어낼 수 있도록 질문은 짧게 진행한다. 
 * After interview
 노트 기록 및 요약
 

**Requirements Description**

Requirements

- a statement of what the system must do or what characteristic it must have. - 시스템이 정확히 무엇을 하는지 명시
- can be changed over time as moves from analysis to design
- can be either functional requirements or nonfuncitional requirements
- Incorrect specification is major reason for project's failure. - 요구사항 명세가 정확하도록 해야 한다.
- Late discovery of problems is costly. - 나중에 발견되는 문제일수록 큰 비용이 발생한다.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-2.PNG)

**Specification Qualities**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-3.PNG)


**요구사항 명세서가 중요한 이유**

요구사항 또는 명세서 자체가 잘못된 경우 다음 단계에 진행되는 과정에서 문제가 발생하고, 그 문제만큼 비용이 크게 증가한다.

따라서 정확히 파악한 요구사항이 정확하게 명세서로 작성될 경우 프로젝트의 변경이 적고 시간소모도 적다.

**Methods for Requirements Analysis & Specification**

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-4.PNG)

**Structured Analysis**

여러가지 분석법 중 구조적 분석방법을 정리합니다.

※ Structured Analysis : Overview

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-5.PNG)

※ Structured Analysis : Overall Process

1. **Brain storming** on the problem and establish the problem statement that describes the key requirements.
2. Identify the events accepted or generated by the system. (And record the results on the **Event Table**)
3. Draw a **System Context Diagram**
4. Decompose diagrams to capture the details as required to describe what the system should do.
 (And record the results on the corresponding **Data Flow Diagram**)
 
5. Describe the internal behavior of each bubble at the **Process Specification**.
6. Define input/output specification of each bubble at the **Data Dictionary**.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/6-6.PNG)

이 외에 좀더 복잡한 로직을 갖고 있다면 State Transition Diagram(STD)를 추가적으로 작성한다.

Contents of SRS
1. Introduction
 - Purpose of this document
 - Project overview
 - Related documents, terms, abbreviations

2. Requirements
 - Data flow diagram
 - Data dictionary
 - Process spec (Mini-spec)
 - Other functional Characteristics

3. Other Requirements or Constraints
 - Performance requirements
 - Hardware requirements
 - Exception handling
 - User interface constraints
 - Other constraints

4. Acceptance Criteria
 - Functionality test criteria
 - Performance test criteria

5. Others
 - Considerable issues

6. Traceability Analysis
 - Traceability matrix

7. References and Appendix

**소프트웨어 개발에 있어서 객체지향 분석 또는 구조적 분석 등 methodology를 선택하는 기준은 무엇인가?**

회사의 방침 또는 프로그래머의 스킬, 구현 언어, 개발 분야 등에 따라서 적합한 방법론을 선택한다.

## 7. Software Design

- A process through which requirements are translated into a representation of software.

- Software design methodology lacks the depth, flexibility and quantitative nature in comparison to classical engineering fields.

요구사항을 소프트웨어로 개발하기 위하여 개발자의 관점에서 작성한다.


**Characteristics of Good Design**

- A design should exhibit a hierarchical structure.
  (계층구조로 보기 쉽게)
- A design should be modular.
  (모듈화)
- A design should contain distinct and separable representation of data and procedure.
 (데이터로 나타낼 부분과 Procesure로 나타내야할 부분을 분리한다.)
- A design should lead to modules that exhibit independent functional characteristics.
 (독립적인 기능을 모듈화한다)
- A design should lead to interfaces that reduce the complexity of connections between modules and with the external environment.
 (외부환경과 결합되기 쉽게 복잡하지 않은 인터페이스로 설계한다.)


**Modularity in details **

※ Coupling

Degree of interdependence between two modules. 

두 모듈 사이의 관계가 형성될때 그 결합강도.


Low coupled system

- Prevent ripple effect - 파급효과 억제
- Enhance understandability - 이해력 향상

Objective: Minimize coupling

- Make modules as independent as possible. - 가능한 독립적인 모듈로 만든다.
- Indicates a well-partitioned system.

How to achieve low coupling

- Eliminating unnecessary relationships - 불필요한 관계를 제거한다.
- Reducing the number of necessary relationships - 필요한 관계도 최소화한다.


※ Scale of Coupling

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/7-1.PNG)

※ Cohesion

The measure of the strength of functional relatedness of elements within a module

(하나의 모듈안에서 각 요소가 공통의 목적을 달성하기 위한 응집도)


Objective: **Maximize Cohesion**

- Make modules whose elements are strongly and genuinely related to one another


Relationship between Coupling and Cohesion

- 2 ways to evaluate the partitioning of a system
- The cohesion of a module often determines how tightly it will be coupled to other modules in a system, and vice versa.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/7-2.PNG)

**좋은 소프트웨어 설계란?**

모듈화 원칙을 지키고 유지보수가 쉽게 할 수 있도록 설계하는 것이다.

모듈화 원칙은 Low Coupling + High Cohesion 이다.




※ Design in Technical aspects

Data design

- transformation of the information domain model created during analysis into the data structures.
 (데이터베이스 설계)

Architectural design
- definition of the relationship among major structural components of the software.
(전체 시스템을 이루는 서브시스템, 모듈 관계파악)

Procedural design

- transformation of structural components into a  procedural description of the software.


(User) Interface design

- establishment of the layout and interaction mechanisms for human-machine interaction.

 (메뉴나 입력양식 설계)
 
** Structured Design : Architectural Design **

A process through which requirements are translated into a representation of software.

![](https://raw.githubusercontent.com/leporem91/leporem91.github.io/master/images/Software_Engineering/7-4.PNG)


**Architectural Design : Task Model**

Task Model

- represents how tasks collaborate with each other to realize the Flow Diagrams

To design task model is the most important work of embedded system development 

- Because it has significant impact system’s performance, reliability, required resource, and so on 



**We develop task models through the following steps **

- Integrating data flow diagrams into a whole DFD.  
- 
- Identifying candidate tasks  

   Each control process can form a ‘Control Task’  

   Process can form a task when it is either Periodic or Asynchronous 

- Allocating remaining processes 

- Merging tasks  


**※ Tips for Allocating Remaining Processes **

Allocating and merging heuristics (응집력과의 관계를 생각한다)

- Control Cohesion 
  Control process may be grouped with the processes it uses into a task 
  For example, triggered synchronous function 

- Sequential Cohesion  
  Certain processes perform operations that must be carried out in a sequential order 

- Temporal Cohesion 
  Certain processes may perform operations that are activated by the same event 

- Functional Cohesion 
  Functional cohesion occurs when there are one or more functions that are closely related 


When a set of tasks are working in a mutually exclusive manner(independent), they can be grouped into a single task


**Structured Design : Detailed Design**


※ Overview of Structured Design

Goal of Structured Design is to build a model to describe how the **system work** (시스템이 어떻게 동작하는지)

Can convert Flow Diagrams into a **structure chart** at task level.

After architectural design, we perform Structured Design for each task 

 - For Flow Diagrams in each task, we convert it into structure chart using modular design strategies
 - Then, we refine the result to describe the enough details of tasks


Structure Chart:
 Modules, Invocations, Couples, Control Abstraction 등의 정해진 Symbols을 이용하여  어떻게  컨트롤하는지를 그린 그림.

 Module Specification :
 모듈의 세부적인 내용을 슈도코드로 작성한 것.
 
 
 **Refining Structure Chart**

* Make each module cohesively  - High Cohesion

* Keep the coupling between modules loosely - Low Coupling

* Factoring - 공통된 속성을 뽑아서 하나의 클래스로 만든다.

* Reduce Fan-Out - 두 개의 모듈을 최대한 합쳐라 ( 다른 모듈을 호출하지 않게)

* Delete Dummy Module 

* Localization for Periodic Process - 데이터를 필요로할때 계속 요청하지 않고 local화하여 값이 변경되었을 때만 알린다.



Contents of  SDD

1. Introduction 
 - Purpose of this document 
 - Project overview 
 - Related documents, terms, abbreviations 

2. Architectural Design 
 - Architecture model 
 - Model description  
 - 
3. Module Design  
 - For each module  
    Design model 
    Module specification 
    
4. Interface Design 
 - Software interface 
 - Communication interface  

5. Data Design 
 - Data structure design 
 - 
6. Implementation Design 
 - Required SW technologies  
 - HW technologies  

7. Others
 - Considerable issues 

8. Traceability Analysis  
 - Traceability matrix  

9. References and Appendix


**What is the difference betwwen DFD and Structure chart?**

 DFD - 데이터의 흐름만 구성 ( 처리관점 )
 
 Structure chart - 실행 개념 ( 컨트롤 관점 )





